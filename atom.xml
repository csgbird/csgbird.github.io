<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CSG博客. 放飞梦想</title>
  <subtitle>csg技术交流博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-14T19:07:10.485Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>陈双刚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scala中&quot;_&quot;的常见用法</title>
    <link href="http://yoursite.com/2017/12/15/scala%E4%B8%AD_%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/15/scala中_的用法/</id>
    <published>2017-12-14T19:07:44.176Z</published>
    <updated>2017-12-14T19:07:10.485Z</updated>
    
    <content type="html"><![CDATA[<p>如题所示<br><a id="more"></a></p>
<h2 id="1-作为函数的参数"><a href="#1-作为函数的参数" class="headerlink" title="1. 作为函数的参数"></a>1. 作为函数的参数</h2><p>一个匿名的函数传递给一个方法或者函数的时候，scala会尽量推断出参数类型。例如一个完整的匿名函数作为参数可以写为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">compute</span></span>(f: (<span class="type">Double</span>)=&gt;<span class="type">Double</span>) = f(<span class="number">3</span>)</div><div class="line">compute: (f: <span class="type">Double</span> =&gt; <span class="type">Double</span>)<span class="type">Double</span></div><div class="line"><span class="comment">//传递一个匿名函数作为compute的参数</span></div><div class="line">scala&gt; compute((x: <span class="type">Double</span>) =&gt; <span class="number">2</span> * x)</div><div class="line">res1: <span class="type">Double</span> = <span class="number">6.0</span></div></pre></td></tr></table></figure>
<p>如果参数x在=&gt;右侧只出现一次，可以用_替代这个参数，简写为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; compute(<span class="number">2</span> * _)</div><div class="line">res2: <span class="type">Double</span> = <span class="number">6.0</span></div></pre></td></tr></table></figure>
<p>更常见的使用方式为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scala&gt; (<span class="number">1</span> to <span class="number">9</span>).filter(_ % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">res0: scala.collection.immutable.<span class="type">IndexedSeq</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</div><div class="line"></div><div class="line">scala&gt; (<span class="number">1</span> to <span class="number">3</span>).map(_ * <span class="number">3</span>)</div><div class="line">res1: scala.collection.immutable.<span class="type">IndexedSeq</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)</div></pre></td></tr></table></figure>
<p>以上所说的为一元函数，那么对于二元函数，即有两个参数x和y的函数，是如何使用_的？可以参考sortWith方法的定义<br><code>def sortWith(lt: (T, T) ⇒ Boolean): Array[T]</code><br>这个方法的参数官方解释为</p>
<blockquote>
<p>the comparison function which tests whether its first argument precedes its second argument in the desired ordering.</p>
</blockquote>
<p>这个方法需要的参数是一个二元函数，而且函数参数的类型为T，例如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="type">List</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>).sortWith(_ &lt; _)</div><div class="line">res0: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>可以用_分别表示二元函数中的参数x和y。</p>
<h2 id="2-作为标识符"><a href="#2-作为标识符" class="headerlink" title="2. 作为标识符"></a>2. 作为标识符</h2><p>例如定义一个变量val _num = 123</p>
<h2 id="3-作为通配符"><a href="#3-作为通配符" class="headerlink" title="3. 作为通配符"></a>3. 作为通配符</h2><p>import语句<br>例如<code>import scala.math._</code><br>case语句<br>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">object MatchTest extends App &#123;</div><div class="line">def matchTest(x: Int): String = x match &#123;</div><div class="line">  case 1 =&gt; &quot;one&quot;</div><div class="line">  case 2 =&gt; &quot;two&quot;</div><div class="line">  case _ =&gt; &quot;many&quot;</div><div class="line">&#125;</div><div class="line">println(matchTest(3))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>元组（tuple）<br>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//可以定义一个tuple</div><div class="line">scala&gt; val t = (1, 3.14, &quot;Fred&quot;)</div><div class="line">t: (Int, Double, String) = (1,3.14,Fred)</div><div class="line">//可以用_1，_2，_3访问这个元组</div><div class="line">scala&gt; t._1</div><div class="line">res3: Int = 1</div><div class="line"></div><div class="line">scala&gt; t._2</div><div class="line">res4: Double = 3.14</div><div class="line"></div><div class="line">scala&gt; t._3</div><div class="line">res5: String = Fred</div></pre></td></tr></table></figure>
<p>可以通过模式匹配获取元组的元素，当不需要某个值的时候可以使用_替代，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scala&gt; val t = (1, 3.14, &quot;Fred&quot;)</div><div class="line">t: (Int, Double, String) = (1,3.14,Fred)</div><div class="line"></div><div class="line">scala&gt; val (first, second, _) = t</div><div class="line">first: Int = 1</div><div class="line">second: Double = 3.14</div><div class="line"></div><div class="line">scala&gt; val (first, _, _) = t</div><div class="line">first: Int = 1</div></pre></td></tr></table></figure>
<h2 id="4-下划线和其他符号组合的使用方式"><a href="#4-下划线和其他符号组合的使用方式" class="headerlink" title="4.下划线和其他符号组合的使用方式"></a>4.下划线和其他符号组合的使用方式</h2><h3 id="4-1-下划线与等号（-）"><a href="#4-1-下划线与等号（-）" class="headerlink" title="4.1 下划线与等号（_=）"></a>4.1 下划线与等号（_=）</h3><p>自定义setter方法，请参见《Overriding def with var in Scala》</p>
<h3 id="4-2-下划线与星号（-）"><a href="#4-2-下划线与星号（-）" class="headerlink" title="4.2 下划线与星号（_*）"></a>4.2 下划线与星号（_*）</h3><p>1.变长参数<br>例如定义一个变长参数的方法sum，然后计算1-5的和，可以写为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scala&gt; def sum(args: Int*) = &#123;</div><div class="line">     | var result = 0</div><div class="line">     | for (arg &lt;- args) result += arg</div><div class="line">     | result</div><div class="line">     | &#125;</div><div class="line">sum: (args: Int*)Int</div><div class="line"></div><div class="line">scala&gt; val s = sum(1,2,3,4,5)</div><div class="line">s: Int = 15</div></pre></td></tr></table></figure>
<p>但是如果使用这种方式就会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">scala&gt; val s = sum(1 to 5)</div><div class="line">&lt;console&gt;:12: error: type mismatch;</div><div class="line"> found   : scala.collection.immutable.Range.Inclusive</div><div class="line"> required: Int</div><div class="line">       val s = sum(1 to 5)</div><div class="line">                     ^</div></pre></td></tr></table></figure>
<p>这种情况必须在后面写上: _*将1 to 5转化为参数序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; val s = sum(1 to 5: _*)</div><div class="line">s: Int = 15</div></pre></td></tr></table></figure>
<h3 id="4-3-变量声明中的模式"><a href="#4-3-变量声明中的模式" class="headerlink" title="4.3.变量声明中的模式"></a>4.3.变量声明中的模式</h3><p>例如，下面代码分别将arr中的第一个和第二个值赋给first和second</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; val arr = Array(1,2,3,4,5)</div><div class="line">arr: Array[Int] = Array(1, 2, 3, 4, 5)</div><div class="line"></div><div class="line">scala&gt; val Array(1, 2, _*) = arr</div><div class="line"></div><div class="line">scala&gt; val Array(first, second, _*) = arr</div><div class="line">first: Int = 1</div><div class="line">second: Int = 2</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如题所示&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/"/>
    
    
      <category term="scala" scheme="http://yoursite.com/tags/scala/"/>
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>HIVE随笔</title>
    <link href="http://yoursite.com/2017/12/15/Hive%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2017/12/15/Hive随笔/</id>
    <published>2017-12-14T18:34:09.713Z</published>
    <updated>2017-12-14T18:39:16.786Z</updated>
    
    <content type="html"><![CDATA[<p>Hive的基本操作,部分优化参数设置。<br><a id="more"></a></p>
<h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h2><p>创建表结构时，指定分隔符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">create table test(uid string,name string)</div><div class="line">row format delimited fields terminated by &apos;/t&apos; </div><div class="line">location &apos;/data/edrive/useraction/log&apos;;</div></pre></td></tr></table></figure>
<p>创建内部表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; CREATE TABLE pokes (foo INT, bar STRING);</div></pre></td></tr></table></figure>
<p>创建外部表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; CREATE external  TABLE pokes (foo INT, bar STRING);</div></pre></td></tr></table></figure></p>
<p>创建一个新表，复制一张表的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; create table new_table like records;</div></pre></td></tr></table></figure>
<p>创建分区表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; create table logs(ts bigint,line string) partitioned by (year String,month String,day stirng);</div></pre></td></tr></table></figure>
<h2 id="2-展示表-分区"><a href="#2-展示表-分区" class="headerlink" title="2. 展示表. 分区"></a>2. 展示表. 分区</h2><p>展示表中有多少分区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; show partitions logs;</div></pre></td></tr></table></figure>
<p>展示所有表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hive&gt; SHOW TABLES;</div><div class="line">        lists all the tables</div><div class="line">hive&gt; SHOW TABLES &apos;.*s&apos;;</div></pre></td></tr></table></figure></p>
<p>显示表的结构信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; DESCRIBE invites;</div></pre></td></tr></table></figure>
<p>描述分区信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">desc extended test partition(dated=&apos;2017-11-15&apos;,stattype=&apos;1&apos;);</div></pre></td></tr></table></figure>
<p>显示所有函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; show functions;</div></pre></td></tr></table></figure>
<p>查看函数用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; describe function substr;</div></pre></td></tr></table></figure>
<p>查看数组、map、结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; select col1[0],col2[&apos;b&apos;],col3.c from complex;</div></pre></td></tr></table></figure>
<h2 id="3-删除操作"><a href="#3-删除操作" class="headerlink" title="3.删除操作"></a>3.删除操作</h2><p>删除表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; DROP TABLE records;</div></pre></td></tr></table></figure></p>
<p>删除表中数据，但要保持表的结构定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; dfs -rmr /user/hive/warehouse/records;</div></pre></td></tr></table></figure></p>
<p>删除表中一个分区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table test drop partition(dated=&apos;2017-11-15&apos;,stattype=1);</div></pre></td></tr></table></figure></p>
<h2 id="4-alter修改表："><a href="#4-alter修改表：" class="headerlink" title="4. alter修改表："></a>4. alter修改表：</h2><p>添加新一列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; ALTER TABLE invites ADD COLUMNS (new_col2 INT COMMENT &apos;a comment&apos;);</div></pre></td></tr></table></figure></p>
<p>表重命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE name RENAME TO new_name</div></pre></td></tr></table></figure>
<p>增加列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE name ADD COLUMNS (col_spec[, col_spec ...])</div></pre></td></tr></table></figure>
<p>删除列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE name DROP [COLUMN] column_name</div></pre></td></tr></table></figure>
<p>修改列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE name CHANGE column_name new_name new_type</div></pre></td></tr></table></figure>
<p>修改所有列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE name REPLACE COLUMNS (col_spec[, col_spec ...])</div></pre></td></tr></table></figure></p>
<p>修改分隔符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table stat_famliy_user_action_log set SERDEPROPERTIES(&apos;field.delim&apos;=&apos;\t&apos;);</div></pre></td></tr></table></figure>
<h2 id="4-导入导出数据："><a href="#4-导入导出数据：" class="headerlink" title="4.导入导出数据："></a>4.导入导出数据：</h2><p>覆盖overwrite数据到表中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; LOAD DATA LOCAL INPATH &apos;/home/hadoop/input/ncdc/micro-tab/sample.txt&apos; OVERWRITE INTO TABLE records;</div></pre></td></tr></table></figure></p>
<p>添加数据到表中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">load data local inpath &apos;/xxx/xxx/file1.txt&apos; into table mytable;</div></pre></td></tr></table></figure></p>
<p>按分区加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">load data local inpath &apos;/xxx/xxx/file1.txt&apos; into table mytable</div><div class="line"> partition(year=&quot;2017&quot;,month=&quot;201702&quot;,day=&quot;20170228&quot;);</div></pre></td></tr></table></figure></p>
<p>按分区覆盖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOAD DATA LOCAL INPATH &apos;/data1/workdir/chenshg/2017jf/jts/ts_login.log.20170322&apos; OVERWRITE INTO TABLE t_jf2017_jts_action  partition(year=&quot;2017&quot;,month=&quot;201703&quot;,day=&quot;20170322&quot;);</div></pre></td></tr></table></figure></p>
<p>导出数据到本地方式1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">insert overwrite local directory &apos;/home/yangping.wu/local&apos;</div><div class="line">     row format delimited</div><div class="line">     fields terminated by &apos;\t&apos;</div><div class="line">     select * from wyp;</div></pre></td></tr></table></figure></p>
<p>导出数据到本地方式2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive -e &quot;select * from wyp&quot; &gt;&gt; local/wyp.txt</div></pre></td></tr></table></figure>
<h2 id="5-复杂操作"><a href="#5-复杂操作" class="headerlink" title="5.复杂操作"></a>5.复杂操作</h2><p>内连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; SELECT sales.*, things.* FROM sales JOIN things ON (sales.id = things.id);</div></pre></td></tr></table></figure>
<p>查看hive为某个查询使用多少个MapReduce作业</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; Explain SELECT sales.*, things.* FROM sales JOIN things ON (sales.id = things.id);</div></pre></td></tr></table></figure>
<p>外连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hive&gt; SELECT sales.*, things.* FROM sales LEFT OUTER JOIN things ON (sales.id = things.id);</div><div class="line">hive&gt; SELECT sales.*, things.* FROM sales RIGHT OUTER JOIN things ON (sales.id = things.id);</div><div class="line">hive&gt; SELECT sales.*, things.* FROM sales FULL OUTER JOIN things ON (sales.id = things.id);</div></pre></td></tr></table></figure>
<p>in查询：Hive不支持，但可以使用LEFT SEMI JOIN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; SELECT * FROM things LEFT SEMI JOIN sales ON (sales.id = things.id);</div></pre></td></tr></table></figure>
<p>Map连接：Hive可以把较小的表放入每个Mapper的内存来执行连接操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; SELECT /*+ MAPJOIN(things) */ sales.*, things.* FROM sales JOIN things ON (sales.id = things.id);</div></pre></td></tr></table></figure>
<p>查询结果插入数据表：INSERT OVERWRITE TABLE ..SELECT：新表预先存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hive&gt; FROM records2</div><div class="line">    &gt; INSERT OVERWRITE TABLE stations_by_year SELECT year, COUNT(DISTINCT station) GROUP BY year</div><div class="line">    &gt; INSERT OVERWRITE TABLE records_by_year SELECT year, COUNT(1) GROUP BY year</div><div class="line">    &gt; INSERT OVERWRITE TABLE good_records_by_year SELECT year, COUNT(1) WHERE temperature != 9999 AND (quality = 0 OR quality = 1 OR quality = 4 OR quality = 5 OR quality = 9) GROUP BY year;</div></pre></td></tr></table></figure>
<p>查询结果插入新建数据表：CREATE TABLE … AS SELECT：新表表预先不存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt;CREATE TABLE target AS SELECT col1,col2 FROM source;</div></pre></td></tr></table></figure>
<p>创建视图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; CREATE VIEW valid_records AS SELECT * FROM records2 WHERE temperature !=9999;</div></pre></td></tr></table></figure>
<p>查看视图详细信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive&gt; DESCRIBE EXTENDED valid_records;</div></pre></td></tr></table></figure>
<h2 id="6、内置函数"><a href="#6、内置函数" class="headerlink" title="6、内置函数"></a>6、内置函数</h2><p>参考：<a href="http://blog.csdn.net/scgaliguodong123_/article/details/46954009" target="_blank" rel="external">HIVE常见内置函数</a><br><a href="http://blog.csdn.net/u011138533/article/details/52302483" target="_blank" rel="external">内置函数列表</a></p>
<h3 id="6-1，collect-set，collect-list内置函数"><a href="#6-1，collect-set，collect-list内置函数" class="headerlink" title="6.1，collect_set，collect_list内置函数"></a>6.1，collect_set，collect_list内置函数</h3><p>列出该字段所有不重复的值，相当于去重<br>collect_set(id) //返回的是数组</p>
<p><code>一般group by时查出来其他重复字段的列，可以使用collect_set(id)</code></p>
<p>列出该字段所有的值，列出来不去重<br>collect_list(id)   //返回的是数组</p>
<h3 id="6-2-UDTF函数：-explpde"><a href="#6-2-UDTF函数：-explpde" class="headerlink" title="6.2 UDTF函数： explpde"></a>6.2 UDTF函数： explpde</h3><p>udtfUDTF有两种使用方法，<strong>一种直接放到select后面</strong>，<strong>一种和lateral view一起使用。</strong><br>1：直接select中使用：<code>select explode_map(properties) as (col1,col2) from src;</code><br>注意：</p>
<ul>
<li>不可以添加其他字段使用：<code>select a, explode_map(properties) as (col1,col2) from src</code></li>
<li>不可以嵌套调用：<code>select explode_map(explode_map(properties)) from src</code></li>
<li>不可以和group by/cluster by/distribute by/sort by一起使用：<code>select 
explode_map(properties) as (col1,col2) from src group by col1, col2</code></li>
</ul>
<p>2：和lateral view一起使用：<code>select src.id, mytable.col1, mytable.col2 from src lateral view explode_map(properties) mytable as col1, col2;</code><br>格式：<strong>lateral view explode函数 表别名 as 列名</strong></p>
<p>此方法更为方便日常使用。执行过程相当于单独执行了两次抽取，然后union到一个表里。</p>
<p><code>lateralView: LATERAL VIEW udtf(expression) tableAlias AS columnAlias (&#39;,&#39; columnAlias)*  
fromClause: FROM baseTable (lateralView)*</code></p>
<font color="red"><strong>ateral view用于和split, explode等UDTF一起使用，它能够将一行数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。lateral view首先为原始表的每行调用UDTF，UTDF会把一行拆分成一或者多行，lateral view再把结果组合，产生一个支持别名表的虚拟表。</strong></font>

<p><code>select id,adid 
 from employee 
 lateral view explode(split(type,&#39;B&#39;)) tt as adid;
 explode</code></p>
<p>把一行转成多行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hive (liguodong)&gt;  select id,adid</div><div class="line">                &gt;  from hiveDemo</div><div class="line">                &gt;  lateral view explode(split(str,&apos;,&apos;)) tt as adid;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20150721205158721" alt="enter image description here"></p>
<h2 id="7-hive常用参数优化设置"><a href="#7-hive常用参数优化设置" class="headerlink" title="7. hive常用参数优化设置"></a>7. hive常用参数优化设置</h2><p>1、  <strong>hive.exec.reducers.max</strong> —&gt;   reducer 个数的上限。<br>默认值：999<br>注：不存在设置Reducer下限个数eg：hive.exec.reducers.min（<strong>X不存在</strong>）</p>
<p> 2、<strong>mapred.reduce.tasks</strong>–&gt; 每个任务reducer数量<br> 默认值：-1<br>注：-1 代表自动根据作业的情况来设置reduce的值 </p>
<p>3、<strong>mapred.min.split.size</strong>—&gt;决定了每个 Input Split的最小值<br>注：map task的数量即mapred.map.tasks的参数值，用户不能直接设置这个参数。Input Split的大小，决定了一个Job拥有多少个map。默认input split的大小是64M（与dfs.block.size的默认值相同）。然而，如果输入的数据量巨大，那么默认的64M的block会有几万甚至几十万的Map Task，集群的网络传输会很大，最严重的是给Job Tracker的调度、队列、内存都会带来很大压力。mapred.min.split.size这个配置项决定了每个 Input Split的最小值，用户可以修改这个参数，从而改变map task的数量。</p>
<p>4、 <strong>hive.exec.parallel</strong><br>    是否开启 map/reduce job的并发提交。<br>5、 <strong>hive.exec.parallel.thread.number：</strong><br>说明：在并行执行时的最大job数，默认是8;</p>
<p>6，重点！！！<br><strong>新的api都采用mapreduce，旧的是mapred</strong><br>mapred.min.split.size和mapreduce.input.fileinputformat.split.minsize是同一参数<br>mapred.max.split.size和mapreduce.input.fileinputformat.split.maxsize使同一参数<br>mapred.map.tasks=mapreduce.job.maps<br>对于map个数的划分：<br>参考文章：<a href="http://www.cnblogs.com/jiaan-geng/p/5462137.html" target="_blank" rel="external">泰山不老生</a><br>HADOOP2.6.0的FILEINPUTFORMAT的任务切分原理分析（即如何控制FILEINPUTFORMAT的MAP任务数量）</p>
<p>细说词频统计实验后各参数的对map个数的影响：<br>两个文件<br>文件wordcount1的内容：</p>
<blockquote>
<p>On the top of the Crumpretty Tree<br>The Quangle Wangle sat,<br>But his face you could not see,<br>On account of his Beaver Hat.</p>
</blockquote>
<p>文件wordcount2的内容：</p>
<blockquote>
<p>But his face you could not see,<br>On account of his Beaver Hat.</p>
</blockquote>
<p>文件上传至/workdir/chenshg/wordcount/input 文件夹下：</p>
<ul>
<li>1、第一次实验：未设置任何参数<br><code>hadoop jar /usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples-2.6.0-cdh5.7.4.jar wordcount /workdir/chenshg/wordcount/input /workdir/chenshg/wordcount/output/result1</code><br><img src="/images/cluster/1493893767541.png" alt="Alt text"><br>个数结果：<strong>splitSize=2，maps=2，reduces=1</strong></li>
<li>2第二次实验：采用mapreduce.job.maps=1 或者3，map结果都不变<br><code>hadoop jar /usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples-2.6.0-cdh5.7.4.jar wordcount  -D mapreduce.job.maps=1  /workdir/chenshg/wordcount/input /workdir/chenshg/wordcount/output/result1</code><br>个数结果：<strong>splitSize=2，maps=2，reduces=1</strong></li>
<li>3第三次实验：设置mapreduce.input.fileinputformat.split.minsize，控制map任务输入划分的最小字节数<br><code>hadoop jar /usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples-2.6.0-cdh5.7.4.jar wordcount  -D mapreduce.input.fileinputformat.split.minsize=1  /workdir/chenshg/wordcount/input /workdir/chenshg/wordcount/output/result1</code><br>结果还是不变：<br>个数结果：<strong>splitSize=2，maps=2，reduces=1</strong></li>
<li><p>4、第四次，采用设置mapreduce.input.fileinputformat.split.maxsize，控制map任务输入划分的最大字节数<br><code>hadoop jar /usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples-2.6.0-cdh5.7.4.jar wordcount  -D mapreduce.input.fileinputformat.split.maxsize=1  /workdir/chenshg/wordcount/input /workdir/chenshg/wordcount/output/result1</code><br>这下结果就发生了变化<br><img src="/images/cluster/1493894328570.png" alt="Alt text"><br><img src="/images/cluster/1493894339566.png" alt="Alt text"><br>个数结果：<strong>splitSize=182，maps=182，reduces=1</strong></p>
</li>
<li><p>第5次实验（借鉴）<br>　阅读文档我们知道dfs.blocksize可以控制块的大小，看看这个参数能否发挥作用。为便于测试，我们首先需要修改hdfs-site.xml中dfs.blocksize的大小为10m（最小就只能这么小，Hadoop限制了参数单位至少是10m）。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">  &lt;name&gt;dfs.blocksize&lt;/name&gt;</div><div class="line">  &lt;value&gt;10m&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>执行普通的wordcount。<br>结果还是不变：<strong>splitSize=2，maps=2，reduces=1</strong></p>
<p>结论：以上实验发现只有mapreduce.input.fileinputformat.split.maxsize参数确实影响了map任务的数量，然后查看源码，具体查看<a href="http://www.cnblogs.com/jiaan-geng/p/5462137.html" target="_blank" rel="external">参考文章</a>。</p>
<p>在遍历files列表的过程中，会获取每个文件的blockSize，最终调用computeSplitSize方法计算每个输入文件应当划分的任务数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protected long computeSplitSize(long blockSize, long minSize,</div><div class="line">long maxSize) &#123;</div><div class="line">  return Math.max(minSize, Math.min(maxSize, blockSize));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以从上面代码中发现每个文件被划分的公式如下：<br>map任务大小：<br><strong><code>map任务要划分的大小（splitSize ）=（maxSize与blockSize之间的最小值）与minSize之间的最大值</code></strong><br>map任务个数：<br><strong><code>map任务划分的数量=输入源文件数目 * (bytesRemaining / splitSize个划分任务+bytesRemaining不能被splitSize 整除的剩余大小单独划分一个任务 )</code></strong><br><strong>bytesRemaining</strong> 是单个输入源文件未划分的字节数<br>总结</p>
<ul>
<li>1、实验1和实验5一样：虽然我们将blockSize设置为10m（最小也只能这么小了，hdfs对于block大小的最低限制），根据以上公式maxSize与blockSize之间的最小值必然是blockSize，而blockSize与minSize之间的最大值也必然是blockSize。说明blockSize实际上已经发挥了作用，它决定了splitSize的大小就是blockSize。由于blockSize大于bytesRemaining，所以并没有对map任务数量产生影响。</li>
<li>2、实验2：由于FileOutputFormat压根没有采用mapreduce.job.maps参数指定的值，所以它当然不会有任何作用。</li>
<li><p>3、实验3：minSize几乎由mapreduce.input.fileinputformat.split.minsize控制；mapreduce.input.fileinputformat.split.maxsize默认的大小是Long.MAX_VALUE，所以splitSize即为maxSize与blockSize之间的最小值；blockSize的默认大小是128m，所以blockSize与值为1的mapreduce.input.fileinputformat.split.minsize之间的最大值为blockSize，即map任务要划分的大小的大小与blockSize相同</p>
</li>
<li><p>4、实验4mapreduce.input.fileinputformat.split.maxsize设置为1时，splitSize的值就是maxsize和minsize中的最大值，因为maxsize和minsize=1，所以split=1；<br><img src="/images/cluster/1493896179744.png" alt="Alt text"><br>而两个文件的总字节数为182个字节，<br>文件1map数=1<em>（120/1+余数0）=120<br>文件2map数=1</em>（62/1+余数0）=62<br>故总map数为182个</p>
</li>
</ul>
<p>结论：<br>针对以上分析，我们用更加容易理解的方式列出这些配置参数的关系：</p>
<ul>
<li>1、当mapreduce.input.fileinputformat.split.maxsize &gt; mapreduce.input.fileinputformat.split.minsize &gt; dfs.blockSize的情况下，此时的splitSize 将由mapreduce.input.fileinputformat.split.minsize参数决定。</li>
<li>2、当mapreduce.input.fileinputformat.split.maxsize &gt; dfs.blockSize &gt; mapreduce.input.fileinputformat.split.minsize的情况下，此时的splitSize 将由dfs.blockSize配置决定。（第二次优化符合此种情况）</li>
<li>3、当dfs.blockSize &gt; mapreduce.input.fileinputformat.split.maxsize &gt; mapreduce.input.fileinputformat.split.minsize的情况下，此时的splitSize 将由mapreduce.input.fileinputformat.split.maxsize参数决定。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hive的基本操作,部分优化参数设置。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hive" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hive/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hive" scheme="http://yoursite.com/tags/Hive/"/>
    
      <category term="sql" scheme="http://yoursite.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop简介</title>
    <link href="http://yoursite.com/2017/12/15/Hadoop%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/12/15/Hadoop简介/</id>
    <published>2017-12-14T17:54:24.220Z</published>
    <updated>2017-12-14T17:56:20.935Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲解了Hadoop的计算模型MapReduce。<br><a id="more"></a></p>
<h2 id="1、Hadoop到底是什么？"><a href="#1、Hadoop到底是什么？" class="headerlink" title="1、Hadoop到底是什么？"></a>1、Hadoop到底是什么？</h2><p>简单地说就是一种处理大量文本数据的编程框架，也可称为解决办法<br>hadoop = hdfs(存取)+mapreduce(处理方法)<br>这里有篇文章里通过生活中的问题描述了hadoop的核心思想，看一下就能明白hadoop到底干什么用的了<br><a href="http://www.aboutyun.com/forum.php?mod=viewthread&amp;tid=5541&amp;highlight=hadoop" target="_blank" rel="external">http://www.aboutyun.com/forum.php?mod=viewthread&amp;tid=5541&amp;highlight=hadoop</a></p>
<h2 id="2、hdfs的认识和流程"><a href="#2、hdfs的认识和流程" class="headerlink" title="2、hdfs的认识和流程"></a>2、hdfs的认识和流程</h2><p>认识了hadoop下面就来介绍hdfs是如何取数据和存放数据的。<br>参考：<a href="http://blog.csdn.net/weixuehao/article/details/16967485" target="_blank" rel="external">http://blog.csdn.net/weixuehao/article/details/16967485</a><br>三个主要角色：</p>
<ul>
<li><strong>NameNode：</strong>是Master节点，是大领导。管理数据块映射，整个目录树结构；处理客户端的读写请求；配置副本策略；管理HDFS的名称空间；</li>
<li><strong>SecondaryNameNode：</strong>是一个小弟，秘书，分担大哥namenode的工作量；是NameNode的冷备份(为大哥工作但不能代替大哥工作)；主要作用：合并fsimage和fsedits然后再发给namenode。</li>
<li><strong>DataNode：</strong>Slave节点，奴隶，干活的。负责存储client发来的数据块block；执行数据块的读写操作。</li>
</ul>
<p>词语解释：</p>
<ul>
<li><strong>热备份：</strong>b是a的热备份，如果a坏掉。那么b马上运行代替a的工作。</li>
<li><strong>冷备份：</strong>b是a的冷备份，如果a坏掉。那么b不能马上代替a工作。但是b上存储a的一些信息，减少a坏掉之后的损失。</li>
<li>namenode<strong>内存</strong>中信息：<ul>
<li>存储的是元数据信息，<strong>fsimage+edits</strong>（当然本地磁盘也存在备份，启动时回加载该信息到内存中）。</li>
</ul>
</li>
<li>namenode<strong>磁盘</strong>存放文件：<ul>
<li><strong>fsimage:</strong>元数据镜像文件（文件系统的目录树，日志操作等。），存储一段时间内namenode内存中存储的是元数据信息</li>
<li><strong>edits：</strong>元数据的操作日志（针对文件系统做的修改操作记录）</li>
<li><strong>fstime:</strong>保存最近一次checkpoint的时间（checkpoint相当于还原点,类似快照时间）。</li>
</ul>
</li>
<li><strong>SecondaryNameNode工作</strong>：负责定时默认1小时或者edits文件达到64M，从namenode上，获取fsimage和edits来进行合并，然后再发送给namenode采用新的fsimage代替原先的fsimage文件，合并<strong>过程中</strong>生成新的edits.new来记录新的操作。合并后，edits.new替换原先的edits并改名edits。fsimage则替换原先的fsimage文件目的：减少namenode的工作量。</li>
<li>元数据是什么，元——mate，元数据——matedata，mate意思是“关于…的..”。元数据就是关于数据的数据信息。参考：<a href="https://www.zhihu.com/question/20679872/answer/65565699" target="_blank" rel="external">https://www.zhihu.com/question/20679872/answer/65565699</a></li>
</ul>
<p>总结：<br>  ①写<strong>1T</strong>文件，我们需要<strong>3T</strong>的存储，<strong>3T</strong>的网络流量带宽。<br>    ②在执行读或写的过程中，NameNode和DataNode通过HeartBeat进行保存通信，确定DataNode活着。如果发现DataNode死掉了，就将死掉的DataNode上的数据，放到其他节点去。读取时，要读其他节点去。<br>    ③挂掉一个节点，没关系，还有其他节点可以备份；甚至，挂掉某一个机架，也没关系；其他机架上，也有备份。</p>
<h2 id="3、MapReduce"><a href="#3、MapReduce" class="headerlink" title="3、MapReduce"></a>3、MapReduce</h2><p>编程模型参考：<a href="http://www.aboutyun.com/thread-7040-1-1.html" target="_blank" rel="external">http://www.aboutyun.com/thread-7040-1-1.html</a><br>整个流程为如下：<br><img src="/images/cluster/1484463005988.png" alt="Alt text"></p>
<ol>
<li><p>首先, 我们能确定我们有一份输入, 而且他的数据量会很大。</p>
</li>
<li><p>通过split之后, 他变成了若干的分片, <strong>每个分片</strong>交给一个<strong>Map作业</strong>处理，（<strong>作业中map函数</strong>中再采用一行一行的读取文本方式）</p>
</li>
<li><p><strong>Map作业</strong>处理完后, tasktracker会把数据进行复制和排序, 然后通过输出的key 和value中间值——》进行 partition的划分 并把每一个<strong>partition</strong>,分区分给一个<strong>Reducer作业</strong>。</p>
</li>
<li><p><strong>Reducer作业</strong>通过处理传来的分区,并把数据输出。 每个相同的key, 一定在一个<strong>reduce函数中</strong>处理完, 每一个<strong>reduce函数</strong>至少对应一份输出(可以通过扩展MultipleOutputFormat来得到多分输出)</p>
<p>注意：<br>可以把Map作业看成Mapper类，Reduce作业看做Reducer类。</p>
</li>
</ol>
<ul>
<li><strong>Map作业</strong>处理一个输入数据的分片，可能需要调用多次<strong>map函数</strong>来处理每个输入键值对；<strong>Reduce作业</strong>处理一个分区的中间键值对，期间要对<strong>每个不同的键调用一次reduce函数</strong>，Reduce作业最终也对应一个输出文件。</li>
<li>分片、 分区和分组的概念：<br><strong>分片:</strong> 是把原始数据大化成小数据并且交给Map处理，比如600M–&gt;6个100M的数据，<strong>一个分片对应一个Map作业</strong><br><strong>分区:</strong> map结果排序后进行区间划分(为了保证合理性中间还有采样等过程),保证了同一个key键值的key-value对必定在同一个分区，当然该分区可包含多个key。<strong>一个分区对应一个Reducer作业类，对应多个reduce函数</strong><br><strong>分组:</strong>把分区中的相同key的值合在一起，这个就是分组，<strong>一个分组对应一个reduce函数处理</strong></li>
</ul>
<p>几个问题：</p>
<ul>
<li><p>mapreduce的过程都包含什么操作？<br>细分每行数据—排序–复制–合并</p>
</li>
<li><p>map处理完后，tasktracer会完成什么任务？<br>tasktracker会把数据进行复制和排序, 然后通过输出的key 和value进行 partition的划分, 并把partition中相同的map(即key相同的键值对)输出, 合并为相同的reduce的输入.</p>
</li>
<li>reducer的作用是什么？<br>把数据输出, 每个相同的key, 一定在一个reduce中处理完, 每一个reduce至少对应一份输出</li>
<li>map中经过谁的处理之后，变为reduce输入？<br>通过shuffle之后, 变成reduce的输入, 这时相同的key对应的value被组合成了一个迭代器</li>
</ul>
<p>下面我按照执行的顺序介绍mapreduce需要经历的几个重要的步骤：</p>
<ul>
<li>1，map任务处理<ul>
<li>1.1读取输入文件内容，解析成key，value对，对输入文件的每一行，解析成key， - value对，每一个键值对调用一次map函数。</li>
<li>1.2写自己的逻辑，对输入的key，value处理，转换成新的key，value输出</li>
<li>1.3对输出的key，value进行分区。</li>
<li>1.4 对不同分区的数据，按照key进行排序，分组，相同key的value放到一个集合中，</li>
<li>1.5（可选）分组后的数据进行归约。</li>
</ul>
</li>
<li>2、reduce任务处理<ul>
<li>2.1 对多个map任务的输出，按照不同的分区，通过网络copy到不同的reduce节点。</li>
<li>2.2对多个map任务的输出进行合并，排序，写reduce函数自己的逻辑，对输入的key，value处理，转换成新的key，value输出，</li>
<li>2.3把reduce的输出保存到文件中。<h3 id="3-1、Map介绍"><a href="#3-1、Map介绍" class="headerlink" title="3.1、Map介绍"></a>3.1、Map介绍</h3><h4 id="3-1-1、map干什么用的"><a href="#3-1-1、map干什么用的" class="headerlink" title="3.1.1、map干什么用的"></a>3.1.1、map干什么用的</h4>简单来说：map就是来把文本变成key-value的键值对。<h4 id="3-1-2、如何来写一个Mapper类"><a href="#3-1-2、如何来写一个Mapper类" class="headerlink" title="3.1.2、如何来写一个Mapper类"></a>3.1.2、如何来写一个Mapper类</h4>编写mapper类，首先需要实现Mapper接口，并规定好输入输出的各种操作，其次就是其中的四个函数。<h4 id="3-1-2-1-定义实现Mapper泛型接口的Mapper类"><a href="#3-1-2-1-定义实现Mapper泛型接口的Mapper类" class="headerlink" title="3.1.2.1 定义实现Mapper泛型接口的Mapper类"></a>3.1.2.1 定义实现Mapper泛型接口的Mapper类</h4>这是词频统计中的map类的实现<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> </span></div><div class="line">    <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;&#123;</div><div class="line"><span class="comment">//这是里定义了输入输出的key-value类型。</span></div><div class="line"><span class="comment">//采用Writable实现int类型，才放入到context中。</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</div><div class="line"><span class="keyword">private</span> Text word = <span class="keyword">new</span> Text();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context</span></span></div><div class="line">                 ) <span class="keyword">throws</span> IOException, InterruptedException &#123;</div><div class="line">   StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</div><div class="line">   <span class="keyword">while</span> (itr.hasMoreTokens()) &#123;</div><div class="line">     word.set(itr.nextToken());</div><div class="line">     context.write(word, one);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>Mapper源码中定义泛型接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class Mapper&lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&gt;</div></pre></td></tr></table></figure>
<p>可以知道我们在实现泛型接口时需要实现以下四个泛型类型，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输入key、输入value-------输出key、输入value</div></pre></td></tr></table></figure>
<p>注意Mapper类的泛型不是java的基本类型，而是Hadoop的数据类型Text、IntWritable。<br>hadoop中的使用数据类型，都需要转化为实现Writable，这样数据能被序列化后完成网络传输或文件输入/输出</p>
<ul>
<li>BooleanWritable:标准布尔型数值——–&gt;boolean</li>
<li>ByteWritable:单字节数值——&gt;byte</li>
<li>DoubleWritable:双字节数值——-&gt;double</li>
<li>FloatWritable:浮点数——&gt;float</li>
<li>IntWritable:整型数———&gt;int</li>
<li>LongWritable:长整型数——-&gt;long</li>
<li>Text:使用UTF8格式存储的文本——对应String</li>
<li>NullWritable:当<key, value="">中的key或value为空时使用。</key,></li>
</ul>
<h4 id="3-1-2-2-Mapper中的四个函数"><a href="#3-1-2-2-Mapper中的四个函数" class="headerlink" title="3.1.2.2 Mapper中的四个函数"></a>3.1.2.2 Mapper中的四个函数</h4><p>在Hadoop的mapper类中，有4个主要的函数，分别是：setup，clearup，map，run</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用map处理之前执行</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line"><span class="comment">// NOTHING</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//文本处理---我们主要的实现的</span></div><div class="line"><span class="comment">/* </span></div><div class="line">   * key:一般是输入长度的偏移量，默认是长整形 ，LongWritable </div><div class="line">   * value：输入文件的一行字符串 </div><div class="line">   * context：上下文对象，利用把map后的输出 </div><div class="line">   */ </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(KEYIN key, VALUEIN value, </span></span></div><div class="line">                     Context context) <span class="keyword">throws</span> IOException, InterruptedException &#123;</div><div class="line">context.write((KEYOUT) key, (VALUEOUT) value);</div><div class="line">&#125;</div><div class="line"><span class="comment">//处理map之后调用</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line"><span class="comment">// NOTHING</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//主函数调用Mapper类需要执行的方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">    setup(context);</div><div class="line">    <span class="keyword">while</span> (context.nextKeyValue()) &#123;</div><div class="line">      map(context.getCurrentKey(), context.getCurrentValue(), context);</div><div class="line">    &#125;</div><div class="line">    cleanup(context);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当调用到map时，通常会先执行一个setup函数，最后会执行一个cleanup函数。而默认情况下，这两个函数的内容都是nothing。因此，当<strong>map方法不符合应用要求时，可以试着通过增加setup和cleanup的内容来满足应用的需求</strong>。</p>
<p>注意一下几点:</p>
<ul>
<li>map函数中的输入 input 默认是一行一条记录, 每行记录都放在value里边，key就是该行的首字母相对于文本文件的首地址的偏移量（也就是该行第一个字符距离第一行第一个字符的中间字符个数），key默认长整形LongWritable</li>
<li>每次搜集一条 K-V记录, 一个K可以对应多个value, 在reduce函数里面体现为一个 iterator</li>
</ul>
<h3 id="3-2、shuffle-性能优化的核心"><a href="#3-2、shuffle-性能优化的核心" class="headerlink" title="3.2、shuffle(性能优化的核心)"></a>3.2、shuffle(性能优化的核心)</h3><ul>
<li>经历的步骤：<br>输入map的结果—&gt;缓冲区—-&gt;sort排序———&gt;combiner合并同key—-&gt;结果n个partition(分区),n也就是后面reduce作业的数量</li>
<li>得到的结果：<br>key–value(相同的key对应的value被组合成了一个迭代器)</li>
</ul>
<p>不过很多人都是把这一步的过程都包含在map的步骤里面，统一称为Map处理。</p>
<h3 id="3-3、reducer作用"><a href="#3-3、reducer作用" class="headerlink" title="3.3、reducer作用"></a>3.3、reducer作用</h3><p>reduce作用：总的来说就是整合各map处理的结果，并输出（文本或数据库）</p>
<h4 id="3-3-1、如何编写一个reduce，"><a href="#3-3-1、如何编写一个reduce，" class="headerlink" title="3.3.1、如何编写一个reduce，"></a>3.3.1、如何编写一个reduce，</h4><p>在Hadoop的reducer类中，有3个主要的函数，分别是：setup，clearup，reduce。代码如下，还有一个run的运行函数。当调用到reduce时，通常会先执行一个setup函数，最后会执行一个cleanup函数。而默认情况下，这两个函数的内容都是nothing。因此，当reduce不符合应用要求时，可以试着通过增加setup和cleanup的内容来满足应用的需求。主要还是编写reduce函数：需要注意的是reduce中的values是迭代器，因为同一个key可能对应多个value值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">protected void reduce(KEYIN key, Iterable&lt;VALUEIN&gt; values, Context context</div><div class="line">                      ) throws IOException, InterruptedException &#123;</div><div class="line">  for(VALUEIN value: values) &#123;</div><div class="line">    context.write((KEYOUT) key, (VALUEOUT) value);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-4-、主函数的设置"><a href="#3-4-、主函数的设置" class="headerlink" title="3.4 、主函数的设置"></a>3.4 、主函数的设置</h3><p>要执行一段hadoop程序得对主函数设置基本信息，<br><code>System.setProperty(&quot;HADOOP_USER_NAME&quot;, &quot;root&quot;);</code>//这句话很重要，要不然会告你没有权限执行,我还暂时没用到这句话<br>路径的输入格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] ioArgs = new String[] &#123; &quot;hdfs://192.168.1.101:7001/input&quot;,</div><div class="line">                &quot;hdfs://192.168.1.101:7001/output&quot; &#125;;</div></pre></td></tr></table></figure></p>
<p>1、定义Job，并命名为“wordCount”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Configuration conf = new Configuration();</div><div class="line">Job job = Job.getInstance(conf ,&quot;wordCount&quot;);</div></pre></td></tr></table></figure>
<p>2、设置jar包的主要运行类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">job.setJarByClass(WordCountTest.class);</div></pre></td></tr></table></figure></p>
<p>   3、设置Mapper与Reudcer的类  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">job.setMapperClass(WordMapper.class);</div><div class="line">job.setCombinerClass(WordReducer.class);</div></pre></td></tr></table></figure>
<p>4.1、设置job的输入输出格式，前者默认是TextInputFormat，后者是FileOutputFormat。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void    setInputFormatClass(Class&lt;? extends InputFormat&gt; cls)  </div><div class="line">void    setOutputFormatClass(Class&lt;? extends OutputFormat&gt; cls)</div></pre></td></tr></table></figure></p>
<p>   4、设置map和reduce的输出键值类型  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//设置map输出的key和value类型 </div><div class="line">job.setMapOutputKeyClass(Class&lt;?&gt; theClass)  </div><div class="line">job.setMapOutputValueClass(Class&lt;?&gt; theClass) </div><div class="line"></div><div class="line">//设置reducer的key和value类型，(通常来说如果map和reduce输出一致，上面的map不设置，下面这两条即可也能指定map的输出)</div><div class="line"> job.setOutputKeyClass(Text.class);</div><div class="line"> job.setOutputValueClass(IntWritable.class);</div></pre></td></tr></table></figure>
<p>   5、设置输入输出路径  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FileInputFormat.addInputPath(job, new Path(otherArgs[0]));</div><div class="line">#可设置多个文件问输入（路径参数可以多个）：FileInputFormat.setInputPaths( job, inputPaths );</div><div class="line">FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));</div></pre></td></tr></table></figure>
<p>6、执行程序job.waitForCompletion(true)<br>一般采用下面的方式，如果配置正确运行。<br>true—打印进度和详情<br>false—–不打印进度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.exit(job.waitForCompletion(true) ? 0 : 1);</div></pre></td></tr></table></figure></p>
<h3 id="3-5，hadoop的动态参数设置"><a href="#3-5，hadoop的动态参数设置" class="headerlink" title="3.5，hadoop的动态参数设置"></a>3.5，hadoop的动态参数设置</h3><p>已打包好的jar包中已经设置了主函数。<br>执行的文件大小为：2 415M<br>hdfs的分片大小默认128M<br>1、采用默认参数执行的jar包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop jar threecount2.jar /workdir/chenshg/all_Login/allLoginLog_2017-05-01 /workdir/chenshg/all_Login/retdir/ret2 20170501</div></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/images/cluster/1494582639220.png" alt="Alt text"><br>mapper个数:19<br>reducer个数：1<br><strong>原因:</strong> 2415/128=18.86…所以大文件会被分为19个片，从而产生了19个map<br>2、动态配置参数的运行jar包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop jar threecount2.jar -Dmapreduce.input.fileinputformat.split.maxsize=536870912 -Dmapreduce.input.fileinputformat.split.minsize=268435456 -Dmapreduce.job.queuename=stat /workdir/chenshg/all_Login/allLoginLog_2017-05-01 /workdir/chenshg/all_Login/retdir/ret2 20170501</div></pre></td></tr></table></figure>
<p><img src="/images/cluster/1494582880215.png" alt="Alt text"><br>mapper个数：10<br>reducer个数：1<br><strong>原因：</strong>按照分片大小的原则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Math.max(minSize, Math.min(maxSize, blockSize));</div></pre></td></tr></table></figure>
<p>而 <code>maxsize（536870912 ）&gt; minSize（268435456 byte=256M） &gt; blockSize（128M）</code><br>所以 ：最终分片大小为minsize,也就是256M为一片，<br>mapper个数=2415/256=9.43=》10个map</p>
<h2 id="4、Myeclipse的远程调试"><a href="#4、Myeclipse的远程调试" class="headerlink" title="4、Myeclipse的远程调试"></a>4、Myeclipse的远程调试</h2><p>在hadoop中的配置hadoop.env.sh文件中加上以下内容，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#远程调试namenode</div><div class="line">export HADOOP_NAMENODE_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8888&quot;</div><div class="line">#远程调试datanode</div><div class="line">export HADOOP_DATANODE_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=9888&quot;</div><div class="line">#远程调试ResourceManager</div><div class="line">#export YARN_RESOURCEMANAGER_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=9568&quot;</div><div class="line">#远程调试nodemanager</div><div class="line">#export YARN_NODEMANAGER_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=9981&quot;</div></pre></td></tr></table></figure></p>
<p>然后在namenode.class中的main主函数中右键debug configurations,<img src="/images/cluster/1485137901045.png" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲解了Hadoop的计算模型MapReduce。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="MapReduce" scheme="http://yoursite.com/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop集群搭建(三)---集群配置</title>
    <link href="http://yoursite.com/2017/12/15/Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA(%E4%B8%89)--%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/12/15/Hadoop集群搭建(三)--集群配置/</id>
    <published>2017-12-14T16:38:37.270Z</published>
    <updated>2017-12-14T17:15:36.005Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍vm安装centos7系统最小设置，采用3个虚拟机搭建大数据集群。安装chd5.7.4版本。<br>参考网址：<a href="http://blog.csdn.net/wisgood/article/details/47721355" target="_blank" rel="external">http://blog.csdn.net/wisgood/article/details/47721355</a><br>各参数说明：<a href="http://www.aboutyun.com/thread-8149-1-1.html" target="_blank" rel="external">http://www.aboutyun.com/thread-8149-1-1.html</a><br><a id="more"></a></p>
<h2 id="1-节点规划"><a href="#1-节点规划" class="headerlink" title="1. 节点规划"></a>1. 节点规划</h2><p>集群各节点角色规划为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">IP地址</th>
<th style="text-align:center">节点名</th>
<th style="text-align:center">HDFS</th>
<th style="text-align:center">Hadoop</th>
<th style="text-align:center">Hbase</th>
<th style="text-align:center">Hive</th>
<th>Impala</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">192.168.2.4</td>
<td style="text-align:center">hadoop-master</td>
<td style="text-align:center">NameNode</td>
<td style="text-align:center">ResourceManager</td>
<td style="text-align:center">HBase</td>
<td style="text-align:center">Hive metastore</td>
<td>Impala Catalog、Impala statestore、Sentry</td>
</tr>
<tr>
<td style="text-align:center">192.168.2.5</td>
<td style="text-align:center">hadoop-slaver1</td>
<td style="text-align:center">DataNode、SecondaryNameNode</td>
<td style="text-align:center">NodeManager</td>
<td style="text-align:center">HBase</td>
<td style="text-align:center">Hive Server2</td>
<td>Impala Server</td>
</tr>
<tr>
<td style="text-align:center">192.168.2.6</td>
<td style="text-align:center">hadoop-slaver2</td>
<td style="text-align:center">DataNode</td>
<td style="text-align:center">NodeManager</td>
<td style="text-align:center">HBase</td>
<td style="text-align:center">Hive Server2</td>
<td>Impala Server</td>
</tr>
</tbody>
</table>
<h2 id="2-安装HDFS"><a href="#2-安装HDFS" class="headerlink" title="2. 安装HDFS"></a>2. 安装HDFS</h2><p>根据节点规划，master 为NameNode节点，slaver1为SecondaryNameNode节点，slaver1 和slaver2 为DataNode节点</p>
<p>在 master节点安装 hadoop-hdfs-namenode：</p>
<p><code>$ yum install hadoop hadoop-hdfs hadoop-client hadoop-doc hadoop-debuginfo hadoop-hdfs-namenode</code></p>
<p>在 slaver1 节点安装 hadoop-hdfs-secondarynamenode</p>
<p><code>$ yum install hadoop-hdfs-secondarynamenode -y</code></p>
<p>在 slaver1、slaver2节点安装 hadoop-hdfs-datanode</p>
<p><code>$ yum install hadoop hadoop-hdfs hadoop-client hadoop-doc hadoop-debuginfo hadoop-hdfs-datanode -y</code></p>
<p>NameNode HA 的配置过程请参考CDH中配置<a href="http://blog.javachen.com/2014/07/18/install-hdfs-ha-in-cdh.html" target="_blank" rel="external">HDFS HA</a>，建议暂时不用配置。</p>
<h2 id="3-配置HDFS"><a href="#3-配置HDFS" class="headerlink" title="3. 配置HDFS"></a>3. 配置HDFS</h2><font color="green"><strong>注: 无论是master节点还是salver节点，其配置文件都是一致的，所以只需修改master节点的配置，然后同步到其他节点即可</strong></font><br>更多配置查看： <a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/ClusterSetup.html" target="_blank" rel="external">Apache Cluster Setup</a><br>## 3.1. 配置namenode<br>配置文件:<code>/etc/hadoop/conf/core-site.xml</code><br>属性：<code>fs.defaultFS</code><br>属性含义: 指定NameNode是哪一个节点以及使用的文件系统是file还是hdfs，<br>value格式：<code>hdfs://&lt;namenode host&gt;:&lt;namenode port&gt;/</code>，默认的文件系统是<code>file:///</code>：<br>具体配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">  &lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class="line">  &lt;value&gt;hdfs://hadoop-master:8020&lt;/value&gt;</div><div class="line">  &lt;description&gt;fs.defaultFS指定namenode在那个节点上&lt;/description&gt; </div><div class="line"> &lt;/property&gt;</div></pre></td></tr></table></figure><br><br>### 3.2. 配置用户组<br><br>配置文件:<code>/etc/hadoop/conf/hdfs-site.xml</code><br>属性:<code>dfs.permissions.superusergroup</code><br>属性含义：该属性指定hdfs的超级用户，默认为hdfs，可以修改为hadoop。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">  &lt;name&gt;dfs.permissions.superusergroup&lt;/name&gt;</div><div class="line">  &lt;value&gt;hadoop&lt;/value&gt;</div><div class="line">  &lt;description&gt;</div><div class="line">     指定hadoop为用户组</div><div class="line">  &lt;/description&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure><br><br>注意：该配置无需手工在linux机器上创建用户组，hdfs初始化启动会自动创建，如果我们初始化启动后会在<code>cat /etc/group</code>就能看到该hadoop组，并且有hdfs，yarn，mapred用户。<br><img src="/images/cluster/1512024289065.png" alt="Alt text"><br><br>### 3.3. 指定本地文件目录<br>- 主要指定namenode、datanode、namesecondary的数据存放目录。hadoop默认的文件路径既权限要求如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">目录							        所有者		权限		默认路径</div><div class="line">hadoop.tmp.dir						hdfs:hdfs	drwx------	/var/hadoop</div><div class="line">dfs.namenode.name.dir				hdfs:hdfs	drwx------	file://$&#123;hadoop.tmp.dir&#125;/dfs/name</div><div class="line">dfs.datanode.data.dir				hdfs:hdfs	drwx------	file://$&#123;hadoop.tmp.dir&#125;/dfs/data</div><div class="line">dfs.namenode.checkpoint.dir			hdfs:hdfs	drwx------	file://$&#123;hadoop.tmp.dir&#125;/dfs/namesecondary</div></pre></td></tr></table></figure><br><br>- 说明你可以在 <code>/etc/hadoop/conf/hdfs-site.xml</code>中只配置hadoop.tmp.dir，也可以分别配置上面的路径。这里使用分别配置的方式，hdfs-site.xml中配置如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line"> &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</div><div class="line"> &lt;value&gt;file:///data/dfs/nn&lt;/value&gt;</div><div class="line"> &lt;description&gt;</div><div class="line">   指定NameNode存储其元数据和编辑日志的目录</div><div class="line"> &lt;/description&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</div><div class="line">&lt;value&gt;file:///data/dfs/dn&lt;/value&gt;</div><div class="line"> &lt;description&gt;</div><div class="line">   指定DataNode存储日志的目录</div><div class="line"> &lt;/description&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">  </div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;dfs.namenode.checkpoint.dir&lt;/name&gt;</div><div class="line">&lt;value&gt;file:///data/dfs/namesecondary&lt;/value&gt;</div><div class="line"> &lt;description&gt;</div><div class="line">   指定SecondaryNameNode存储日志的目录</div><div class="line"> &lt;/description&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure><br><br>- 在<strong>NameNode（hadoop-master）</strong>上手动创建 <code>dfs.name.dir</code> 或 <code>dfs.namenode.name.dir</code> 的本地目录：(<code>dfs.name.dir</code> 或 <code>dfs.namenode.name.dir</code> 是一样的由于版本问题名字后面的取代了前面)<br>因为master只有namenode,所以只需要创建namenode对应的目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir -p /data/dfs/nn</div><div class="line">$ chown -R hdfs:hdfs /data/dfs/nn</div></pre></td></tr></table></figure><br><br>在<strong>DataNode（hadoop-slaver1，hadoop-slaver2）</strong>上手动创建 <code>dfs.data.dir</code> 或 <code>dfs.datanode.data.dir</code> 的本地目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir -p /data/dfs/dn</div><div class="line">$ chown -R hdfs:hdfs /data/dfs/dn</div></pre></td></tr></table></figure><br><br>按照上面的<code>chown -R</code>命令修改目录所有者<br><br>### 3.4. 配置 SecondaryNameNode<br>配置文件:<code>/etc/hadoop/conf/hdfs-site.xml</code><br>属性:<code>dfs.secondary.http.address</code><br>value含义:secondaryNameNode的http指向的节点<br>具体配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">  &lt;name&gt;dfs.secondary.http.address&lt;/name&gt;</div><div class="line">  &lt;value&gt;hadoop-slaver1:50090&lt;/value&gt;</div><div class="line">  &lt;description&gt; </div><div class="line">   指定第slaver1为nameSecond节点</div><div class="line">  &lt;/description&gt;</div><div class="line"> &lt;/property&gt;</div></pre></td></tr></table></figure><br><br>- 还可以添加如下参数(我暂时没配置这些)：<br>含义参考:<a href="http://blog.cloudera.com/blog/2014/03/a-guide-to-checkpointing-in-hadoop/" target="_blank" rel="external">http://blog.cloudera.com/blog/2014/03/a-guide-to-checkpointing-in-hadoop/</a><br>格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">   &lt;name&gt;属性名&lt;/name&gt;</div><div class="line">   &lt;value&gt;值&lt;/value&gt;</div><div class="line">&lt;property&gt;</div></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dfs.namenode.checkpoint.check.period</div><div class="line">dfs.namenode.checkpoint.txns</div><div class="line">dfs.namenode.checkpoint.dir</div><div class="line">dfs.namenode.checkpoint.edits.dir</div><div class="line">dfs.namenode.num.checkpoints.retained</div></pre></td></tr></table></figure><br><br>设置多个secondarynamenode，请参考<a href="http://blog.cloudera.com/blog/2009/02/multi-host-secondarynamenode-configuration/" target="_blank" rel="external">multi-host-secondarynamenode-configuration.</a><br><br>### 3.5. 开启回收站功能<br><br>回收站功能默认是关闭的，建议打开。在 <code>/etc/hadoop/conf/core-site.xml</code> 中添加如下两个参数：<br><code>fs.trash.interval</code>，该参数值为时间间隔，单位为<strong>分钟</strong>，默认为0，表示回收站功能关闭。该值表示回收站中文件保存多长时间，如果服务端配置了该参数，则忽略客户端的配置；如果服务端关闭了该参数，则检查客户端是否有配置该参数；<br><code>fs.trash.checkpoint.interval</code>，该参数值为时间间隔，单位为<strong>分钟</strong>，默认为0。该值表示检查回收站时间间隔，该值要<strong>小于fs.trash.interval</strong>，该值在服务端配置。如果该值设置为0，则使用 <strong>fs.trash.interval 的值</strong>，<br>具体配置：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line"> &lt;name&gt;fs.trash.interval&lt;/name&gt;</div><div class="line"> &lt;value&gt;1440&lt;/value&gt;</div><div class="line"> &lt;description&gt;</div><div class="line">    回收站功能开启，1440分钟,一天</div><div class="line"> &lt;/description&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure><br><br>### 3.6. 配置负载均衡<br>在 <code>/etc/hadoop/conf/hdfs-site.xml</code> 中配置以下三个参数：（我也不会，暂时未配置）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dfs.datanode.fsdataset. volume.choosing.policy</div><div class="line">dfs.datanode.available-space-volume-choosing-policy.balanced-space-threshold</div><div class="line">dfs.datanode.available-space-volume-choosing-policy.balanced-space-preference-fraction</div></pre></td></tr></table></figure><br><br>### 3.7. 开启WebHDFS<br><br>在NameNode节点上安装：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install hadoop-httpfs -y</div></pre></td></tr></table></figure><br><br>然后修改 /etc/hadoop/conf/core-site.xml配置代理用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;  </div><div class="line">	&lt;name&gt;hadoop.proxyuser.httpfs.hosts&lt;/name&gt;  </div><div class="line">	&lt;value&gt;*&lt;/value&gt;  </div><div class="line">&lt;/property&gt;  </div><div class="line">&lt;property&gt;  </div><div class="line">	&lt;name&gt;hadoop.proxyuser.httpfs.groups&lt;/name&gt;  </div><div class="line">	&lt;value&gt;*&lt;/value&gt;  </div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure><br><br>### 3.8. 配置LZO<br><br>下载repo文件到 <code>/etc/yum.repos.d/:</code><br>如果你安装的是 CDH5，请下载<a href="http://archive.cloudera.com/gplextras5/redhat/7/x86_64/gplextras/cloudera-gplextras5.repo" target="_blank" rel="external">Red Hat/CentOS 7</a><br>按照之前课程二的那样：<br><code>/etc/yum.repos.d/CentOS-Cloudera.repo</code>添加<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[cloudera-gplextras5]</div><div class="line">name=Cloudera&apos;s Distribution for Hadoop, Version 5</div><div class="line">baseurl=https://archive.cloudera.com/gplextras5/redhat/7/x86_64/gplextras/5/</div><div class="line">gpgkey =https://archive.cloudera.com/gplextras5/redhat/7/x86_64/gplextras/RPM-GPG-KEY-cloudera    </div><div class="line">gpgcheck = 1</div></pre></td></tr></table></figure><br><br>进入到之前配置的本地yum仓库，下载<code>cloudera-gplextras5</code>仓库文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/bigdata</div><div class="line">reposync -r cloudera-gplextras5</div><div class="line">cp cloudera-gplextras5/RPMS/x86_64/* cdh/5/RPMS/x86_64/</div><div class="line">cd /usr/local/bigdata/cdh/5</div><div class="line">createrepo .    #在该目录下创建yum的新元数据文件</div><div class="line">yum clean all        #清理缓存</div></pre></td></tr></table></figure><br><br>在所有节点安装LZO<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install hadoop-lzo* impala-lzo  -y</div></pre></td></tr></table></figure><br><br>在 <code>/etc/hadoop/conf/core-site.xml</code> 中添加如下配置：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">  &lt;name&gt;io.compression.codecs&lt;/name&gt;</div><div class="line">  &lt;value&gt;org.apache.hadoop.io.compress.DefaultCodec,org.apache.hadoop.io.compress.GzipCodec,</div><div class="line">org.apache.hadoop.io.compress.BZip2Codec,com.hadoop.compression.lzo.LzoCodec,</div><div class="line">com.hadoop.compression.lzo.LzopCodec&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">  &lt;name&gt;io.compression.codec.lzo.class&lt;/name&gt;</div><div class="line">  &lt;value&gt;com.hadoop.compression.lzo.LzoCodec&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure><br><br>### 3.9. 同步配置文件到slaver节点<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ scp -r /etc/hadoop/conf root@hadoop-slaver1:/etc/hadoop/</div><div class="line">$ scp -r /etc/hadoop/conf root@hadoop-slaver2:/etc/hadoop/</div></pre></td></tr></table></figure><br><br>### 3.10. 启动HDFS<br><br>在master中格式化NameNode：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo -u hdfs hadoop namenode -format</div></pre></td></tr></table></figure><br><br>在<font color="red"><strong>每个节点</strong></font>运行下面命令启动hdfs：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ for x in `ls /etc/init.d/|grep  hadoop-hdfs`; do service $x start; done</div></pre></td></tr></table></figure><br><br><img src="/images/cluster/1512028800416.png" alt="Alt text"><br><br>在 hdfs 运行之后，创建 /tmp 临时目录，并设置权限为 1777：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo -u hdfs hadoop fs -mkdir /tmp</div><div class="line">$ sudo -u hdfs hadoop fs -chmod -R 1777 /tmp</div></pre></td></tr></table></figure><br><br>如果安装了HttpFS，则启动 HttpFS 服务：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service hadoop-httpfs start</div></pre></td></tr></table></figure><br><br>### 3.11.  测试<br><br>1、通过 <a href="http://192.168.2.4:50070/" target="_blank" rel="external">http://192.168.2.4:50070/</a> 可以访问 NameNode 页面。<br><img src="/images/cluster/1512029163293.png" alt="Alt text"><br><br>2、使用 curl 运行下面命令，可以测试 webhdfs 并查看执行结果：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &quot;http://192.168.2.4:14000/webhdfs/v1?op=gethomedirectory&amp;user.name=hdfs&quot;</div></pre></td></tr></table></figure><br><br><img src="/images/cluster/1512029306943.png" alt="Alt text"><br><br>## 4. 安装配置yarn<br><br><font color="green"><strong>注: 无论是master节点还是salver节点，其配置文件都是一致的，所以只需修改master节点的配置，然后同步到其他节点即可</strong></font><br>可以参考官网查看每个节点需要安装什么软件的：<a href="https://www.cloudera.com/documentation/enterprise/5-7-x/topics/cdh_ig_cdh5_install.html#topic_4_4_4" target="_blank" rel="external">https://www.cloudera.com/documentation/enterprise/5-7-x/topics/cdh_ig_cdh5_install.html#topic_4_4_4</a><br><br>hadoop-yarn 属于yarn的依赖包，都需要安装。<br>- 在 <strong>master</strong> 节点安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ yum install hadoop-yarn hadoop-yarn-resourcemanager -y</div><div class="line">#安装 historyserver</div><div class="line">$ yum install hadoop-mapreduce-historyserver hadoop-yarn-proxyserver -y</div></pre></td></tr></table></figure><br><br>- 在 <strong>slaver</strong> 节点安装计算软件<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install hadoop-yarn hadoop-yarn-nodemanager hadoop-mapreduce -y</div></pre></td></tr></table></figure><br><br>### 4.1. 配置yarn模式<br>要想使用YARN，需要在 <code>/etc/hadoop/conf/mapred-site.xml</code> 中做如下配置:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">       &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</div><div class="line">       &lt;value&gt;yarn&lt;/value&gt;</div><div class="line">       &lt;description&gt;如果采用yarn的运行方式，必须配置该参数为yarn&lt;/description&gt;</div><div class="line">  &lt;/property&gt;</div></pre></td></tr></table></figure><br><br>### 4.2. 配置resourceManager<br>修改<code>/etc/hadoop/conf/yarn-site.xml</code>，配置resourcemanager的节点名称以及一些服务的端口号：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">  &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;</div><div class="line">  &lt;value&gt;hadoop-master:8031&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">  &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;</div><div class="line">  &lt;value&gt;hadoop-master:8032&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">  &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;</div><div class="line">  &lt;value&gt;hadoop-master:8030&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">  &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt;</div><div class="line">  &lt;value&gt;hadoop-master:8033&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">  &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;</div><div class="line">  &lt;value&gt;hadoop-master:8088&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure><br><br>### 4.3. 其他配置<br>（我的配置文件中已经默认配置了这些参数，所以不再配置）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</div><div class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;yarn.nodemanager.aux-services.mapreduce_shuffle.class&lt;/name&gt;</div><div class="line">    &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</div><div class="line">    &lt;value&gt;true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;yarn.application.classpath&lt;/name&gt;</div><div class="line">   &lt;value&gt;</div><div class="line">    $HADOOP_CONF_DIR,</div><div class="line">    $HADOOP_COMMON_HOME/*,</div><div class="line">    $HADOOP_COMMON_HOME/lib/*,</div><div class="line">    $HADOOP_HDFS_HOME/*,</div><div class="line">    $HADOOP_HDFS_HOME/lib/*,</div><div class="line">    $HADOOP_MAPRED_HOME/*,</div><div class="line">    $HADOOP_MAPRED_HOME/lib/*,</div><div class="line">    $HADOOP_YARN_HOME/*,</div><div class="line">    $HADOOP_YARN_HOME/lib/*</div><div class="line">    &lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">	&lt;name&gt;yarn.log.aggregation.enable&lt;/name&gt;</div><div class="line">	&lt;value&gt;true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure><br><br><font color="red"><strong>注意：</strong></font>

<ul>
<li><code>yarn.nodemanager.aux-services</code> 的值在 <code>cdh4</code> 中应该为 <code>mapreduce.shuffle</code>，并配置参数<code>yarn.nodemanager.aux-services.mapreduce.shuffle.class</code>值为<code>org.apache.hadoop.mapred.ShuffleHandler</code> ，</li>
<li><p>在<code>cdh5</code>中为<code>mapreduce_shuffle</code>，这时候请配置<code>yarn.nodemanager.aux-services.mapreduce_shuffle.class</code>参数</p>
</li>
<li><p>这里配置了 <code>yarn.application.classpath</code> 所以需要配置环境变量，添加<br><code>vi /etc/profile</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">export HADOOP_HOME=/usr/lib/hadoop</div><div class="line">export HIVE_HOME=/usr/lib/hive</div><div class="line">export HBASE_HOME=/usr/lib/hbase</div><div class="line">export HADOOP_HDFS_HOME=/usr/lib/hadoop-hdfs</div><div class="line">export HADOOP_MAPRED_HOME=/usr/lib/hadoop-mapreduce</div><div class="line">export HADOOP_COMMON_HOME=$&#123;HADOOP_HOME&#125;</div><div class="line">export HADOOP_HDFS_HOME=/usr/lib/hadoop-hdfs</div><div class="line">export HADOOP_LIBEXEC_DIR=$&#123;HADOOP_HOME&#125;/libexec</div><div class="line">export HADOOP_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</div><div class="line">export HDFS_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</div><div class="line">export HADOOP_YARN_HOME=/usr/lib/hadoop-yarn</div><div class="line">export YARN_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</div></pre></td></tr></table></figure>
<h3 id="4-4-hadoop默认文件路径配置"><a href="#4-4-hadoop默认文件路径配置" class="headerlink" title="4.4. hadoop默认文件路径配置"></a>4.4. hadoop默认文件路径配置</h3><p>在hadoop中默认的文件路径以及权限要求如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">目录									                   所有者		 权限		        默认路径</div><div class="line">yarn.nodemanager.local-dirs			  yarn:yarn	  drwxr-xr-x    $&#123;hadoop.tmp.dir&#125;/nm-local-dir</div><div class="line">yarn.nodemanager.log-dirs			  yarn:yarn	  drwxr-xr-x	  $&#123;yarn.log.dir&#125;/userlogs</div><div class="line">yarn.nodemanager.remote-app-log-dir							                hdfs://cdh1:8020/var/log/hadoop-yarn/apps</div></pre></td></tr></table></figure>
<p>故在 <code>/etc/hadoop/conf/yarn-site.xml</code> 文件中添加如下配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">  &lt;description&gt;List of directories to store localized files in.&lt;/description&gt;</div><div class="line">  &lt;name&gt;yarn.nodemanager.local-dirs&lt;/name&gt;</div><div class="line">  &lt;value&gt;/data/yarn/local&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">  &lt;description&gt;Where to store container logs.&lt;/description&gt;</div><div class="line">  &lt;name&gt;yarn.nodemanager.log-dirs&lt;/name&gt;</div><div class="line">  &lt;value&gt;/data/yarn/logs&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">  &lt;description&gt;Where to aggregate logs to.&lt;/description&gt;</div><div class="line">  &lt;name&gt;yarn.nodemanager.remote-app-log-dir&lt;/name&gt;</div><div class="line">  &lt;value&gt;/yarn/apps&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>创建 <code>yarn.nodemanager.local-dirs</code> 和 <code>yarn.nodemanager.log-dirs</code> 参数对应的目录(<strong>在每个节点都创建</strong>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir -p /data/yarn/&#123;local,logs&#125;</div><div class="line">$ chown -R yarn:yarn /data/yarn</div></pre></td></tr></table></figure></p>
<p>在 hdfs 上创建 <code>yarn.nodemanager.remote-app-log-dir</code> 对应的目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo -u hdfs hadoop fs -mkdir -p /yarn/apps</div><div class="line">$ sudo -u hdfs hadoop fs -chown yarn:mapred /yarn/apps</div><div class="line">$ sudo -u hdfs hadoop fs -chmod 1777 /yarn/apps</div></pre></td></tr></table></figure>
<p>在 <code>/etc/hadoop/conf/mapred-site.xml</code> 中配置 MapReduce History Server：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</div><div class="line">    &lt;value&gt;hadoop-master:10020&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</div><div class="line">    &lt;value&gt;hadoop-master:19888&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>此外，确保 mapred、yarn 用户能够使用代理，在 <code>/etc/hadoop/conf/core-site.xml</code> 中添加如下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;hadoop.proxyuser.mapred.groups&lt;/name&gt;</div><div class="line">    &lt;value&gt;*&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;hadoop.proxyuser.mapred.hosts&lt;/name&gt;</div><div class="line">    &lt;value&gt;*&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;hadoop.proxyuser.yarn.groups&lt;/name&gt;</div><div class="line">    &lt;value&gt;*&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;hadoop.proxyuser.yarn.hosts&lt;/name&gt;</div><div class="line">    &lt;value&gt;*&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<p> <code>mapred-site.xml</code>配置 Staging 目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;yarn.app.mapreduce.am.staging-dir&lt;/name&gt;</div><div class="line">    &lt;value&gt;/user&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>并在 hdfs 上创建相应的目录授权：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo -u hdfs hadoop fs -mkdir -p /user</div><div class="line">$ sudo -u hdfs hadoop fs -chmod 777 /user</div></pre></td></tr></table></figure>
<h3 id="4-5-可选配置"><a href="#4-5-可选配置" class="headerlink" title="4.5. 可选配置"></a>4.5. 可选配置</h3><p>可选的，你可以在 <code>/etc/hadoop/conf/mapred-site.xml</code> 设置以下两个参数：</p>
<p><code>mapreduce.jobhistory.intermediate-done-dir</code>，该目录权限应该为1777，默认值为 <code>${yarn.app.mapreduce.am.staging-dir}/history/done_intermediate</code><br><code>mapreduce.jobhistory.done-dir</code>，该目录权限应该为750，默认值为 <code>${yarn.app.mapreduce.am.staging-dir}/history/done</code><br>然后，在 hdfs 上创建目录并设置权限：</p>
<p>（我进行配置，采用它本身的默认值，执行了如下命令）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> &lt;property&gt;</div><div class="line"> &lt;name&gt;mapreduce.jobhistory.intermediate-done-dir&lt;/name&gt;</div><div class="line"> &lt;value&gt;/user/history/done_intermediate&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line"> &lt;name&gt;mapreduce.jobhistory.done-dir&lt;/name&gt;</div><div class="line"> &lt;value&gt;/user/history/done&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ sudo -u hdfs hadoop fs -mkdir -p /user/history</div><div class="line">$ sudo -u hdfs hadoop fs -chmod -R 1777 /user/history</div><div class="line">$ sudo -u hdfs hadoop fs -chown mapred:hadoop /user/history</div><div class="line"></div><div class="line">$ sudo -u hdfs hadoop fs -mkdir -p /user/history/done_intermediate</div><div class="line">$ sudo -u hdfs hadoop fs -chmod -R 1777 /user/history/done_intermediate</div><div class="line">$ sudo -u hdfs hadoop fs -chown mapred:hadoop /user/history/done_intermediate</div><div class="line"></div><div class="line">$ sudo -u hdfs hadoop fs -mkdir -p /user/history/done</div><div class="line">$ sudo -u hdfs hadoop fs -chmod -R 750 /user/history/done</div><div class="line">$ sudo -u hdfs hadoop fs -chown mapred:hadoop /user/history/done</div></pre></td></tr></table></figure>
<p>设置 <code>HADOOP_MAPRED_HOME</code>，或者把其加入到 <code>/etc/profile</code> 的配置文件中<br>我把它加到该配置文件中（记得执行<code>source /etc/profile</code>使配置文件生效）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ export HADOOP_MAPRED_HOME=/usr/lib/hadoop-mapreduce</div></pre></td></tr></table></figure></p>
<h3 id="4-6-验证-HDFS-结构："><a href="#4-6-验证-HDFS-结构：" class="headerlink" title="4.6.  验证 HDFS 结构："></a>4.6.  验证 HDFS 结构：</h3><p><code>$ sudo -u hdfs hadoop fs -ls -R /</code></p>
<p>你应该看到如下结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">drwxrwxrwt   - hdfs hadoop          0 2014-04-19 14:21 /tmp</div><div class="line">drwxrwxrwx   - hdfs hadoop          0 2014-04-19 14:26 /user</div><div class="line">drwxrwxrwt   - mapred hadoop        0 2014-04-19 14:31 /user/history</div><div class="line">drwxr-x---   - mapred hadoop        0 2014-04-19 14:38 /user/history/done</div><div class="line">drwxrwxrwt   - mapred hadoop        0 2014-04-19 14:48 /user/history/done_intermediate</div><div class="line">drwxr-xr-x   - hdfs   hadoop        0 2014-04-19 15:31 /yarn</div><div class="line">drwxrwxrwt   - yarn   mapred        0 2014-04-19 15:31 /yarn/apps</div></pre></td></tr></table></figure></p>
<h3 id="4-7-同步配置文件"><a href="#4-7-同步配置文件" class="headerlink" title="4.7. 同步配置文件"></a>4.7. 同步配置文件</h3><p>同步配置文件到整个集群:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ scp -r /etc/hadoop/conf root@hadoop-slaver1:/etc/hadoop/</div><div class="line">$ scp -r /etc/hadoop/conf root@hadoop-slaver2:/etc/hadoop/</div></pre></td></tr></table></figure>
<h3 id="4-8-启动yarn"><a href="#4-8-启动yarn" class="headerlink" title="4.8. 启动yarn"></a>4.8. 启动yarn</h3><ul>
<li>在<font color="red"><strong>每个节点</strong></font>启动 YARN :<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ for x in `ls /etc/init.d/|grep hadoop-yarn` ; do service $x start ; done</div></pre></td></tr></table></figure>
</li>
</ul>
<p>我最开始在master启动出现proxyserver启动失败（就是安装的<code>hadoop-yarn-proxyserver</code>，虽然不知道这东西有什么用，而且看官网也没安装这玩意），查看日志发现说<code>yarn.web-proxy.address</code>没有设置，<br><img src="/images/cluster/1512036969603.png" alt="Alt text"><br>所以又在<code>/etc/hadoop/conf/yarn-site.xml</code>添加 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;/property&gt;</div><div class="line">   &lt;property&gt;</div><div class="line">   &lt;name&gt;yarn.web-proxy.address&lt;/name&gt;</div><div class="line">   &lt;value&gt;hadoop-master&lt;/value&gt;</div><div class="line"> &lt;/property&gt;</div></pre></td></tr></table></figure>
<p>配置文件也同步到各个节点去。<br>启动成功<br><img src="/images/cluster/1512036893212.png" alt="Alt text"></p>
<h3 id="4-9-测试yarn"><a href="#4-9-测试yarn" class="headerlink" title="4.9 测试yarn"></a>4.9 测试yarn</h3><p>通过 <a href="http://192.168.2.4:8088/" target="_blank" rel="external">http://192.168.2.4:8088/</a> 可以访问 Yarn 的管理页面，查看在线的节点：<a href="http://192.168.2.4:8088/cluster/nodes。" target="_blank" rel="external">http://192.168.2.4:8088/cluster/nodes。</a></p>
<p><img src="/images/cluster/1512038667483.png" alt="Alt text"></p>
<p>运行下面的测试程序，看是否报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># Find how many jars name ending with examples you have inside location /usr/lib/按照规则搜索jar包</div><div class="line">$ find /usr/lib/ -name &quot;*hadoop*examples*.jar&quot;</div><div class="line"></div><div class="line"># To list all the class name inside jar搜索指定jar包所有class</div><div class="line">$ find /usr/lib/ -name &quot;hadoop-examples.jar&quot; | xargs -0 -I &apos;&#123;&#125;&apos; sh -c &apos;jar tf &#123;&#125;&apos;</div><div class="line"></div><div class="line"># To search for specific class name inside jar搜索指定jar包指定class</div><div class="line">$ find /usr/lib/ -name &quot;hadoop-examples.jar&quot; | xargs -0 -I &apos;&#123;&#125;&apos; sh -c &apos;jar tf &#123;&#125;&apos; | grep -i wordcount.class</div><div class="line"></div><div class="line"># 运行 randomwriter 例子</div><div class="line">$ sudo -u hdfs hadoop jar /usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar randomwriter out</div></pre></td></tr></table></figure>
<p>运行出错<br><img src="/images/cluster/1512039451061.png" alt="Alt text"><br>所以需要在配置副本参数：</p>
<p>不过我的电脑内存已经挤爆了，执行非常非常非常慢。目前为止应该都是成功的,接下来安装zookeeper,hbase,hive等,参考文章开头的博客地址即可.<br><img src="/images/cluster/1512038975646.png" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍vm安装centos7系统最小设置，采用3个虚拟机搭建大数据集群。安装chd5.7.4版本。&lt;br&gt;参考网址：&lt;a href=&quot;http://blog.csdn.net/wisgood/article/details/47721355&quot;&gt;http://blog.csdn.net/wisgood/article/details/47721355&lt;/a&gt;&lt;br&gt;各参数说明：&lt;a href=&quot;http://www.aboutyun.com/thread-8149-1-1.html&quot;&gt;http://www.aboutyun.com/thread-8149-1-1.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="HDFS" scheme="http://yoursite.com/tags/HDFS/"/>
    
      <category term="Yarn" scheme="http://yoursite.com/tags/Yarn/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop集群搭建(二)--软件安装</title>
    <link href="http://yoursite.com/2017/12/15/Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA(%E4%BA%8C)---%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2017/12/15/Hadoop集群搭建(二)---软件安装/</id>
    <published>2017-12-14T16:09:02.148Z</published>
    <updated>2017-12-14T18:49:13.252Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍vm安装centos7系统最小设置，采用3个虚拟机搭建大数据集群。安装chd5.7.4版本。<br>参考网址：<a href="https://www.cloudera.com/documentation/enterprise/5-7-x/topics/cdh_ig_command_line.html" target="_blank" rel="external">https://www.cloudera.com/documentation/enterprise/5-7-x/topics/cdh_ig_command_line.html</a><br><a id="more"></a></p>
<p>前面已经讲解了三台机器<code>hadoop-master</code>、<code>hadoop-slaver1</code>、<code>hadoop-slaver2</code>的基本环境配置，下面在master机器上搭建yum服务器，然后只需要master下载安装包，slaver1，slaver2就能够直接从master下载安装无需在通过网络。</p>
<h2 id="1-创建本地yum仓库。"><a href="#1-创建本地yum仓库。" class="headerlink" title="1. 创建本地yum仓库。"></a>1. 创建本地yum仓库。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /etc/yum.repos.d/ #进入yum的配置文件</div><div class="line">vi CentOS-Cloudera.repo #创建新仓库文件</div></pre></td></tr></table></figure>
<p>创建yum的cloudera仓库文件：添加如下内容。指定到5.7.4的版本，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[cloudera-cdh5.7.4]</div><div class="line"># Packages for Cloudera&apos;s Distribution for Hadoop, Version 5, on RedHat or CentOS 7 x86_64</div><div class="line">name=Cloudera&apos;s Distribution for Hadoop, Version 5</div><div class="line">baseurl=https://archive.cloudera.com/cdh5/redhat/7/x86_64/cdh/5.7.4/</div><div class="line">gpgkey =https://archive.cloudera.com/cdh5/redhat/7/x86_64/cdh/RPM-GPG-KEY-cloudera</div><div class="line">gpgcheck = 0</div></pre></td></tr></table></figure></p>
<p>安装yum-utils,和creterepo工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install yum-utils createrepo</div></pre></td></tr></table></figure></p>
<p>同步仓库,从先前<code>/etc/yum.repos.d/CentOS-Cloudera.repo</code>文件中的<code>[cloudera-cdh5.7.4]</code>路径下同步需要的软件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd /usr/local</div><div class="line">mkdir bigdata</div><div class="line">cd bigdata</div><div class="line">reposync -r cloudera-cdh5.7.4         #同步软件,cloudera-cdh5.7.4表示yum中的一个配置仓库名</div></pre></td></tr></table></figure></p>
<h2 id="2-搭建简单的apache的web服务器"><a href="#2-搭建简单的apache的web服务器" class="headerlink" title="2. 搭建简单的apache的web服务器"></a>2. 搭建简单的apache的web服务器</h2><p>搭建web服务器作为savler1，savler2 的yum安装软件源网址，只需要master从网络中下载cdh软件，其他savler机器以后从master中获取该软件下载即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span>  /usr/<span class="built_in">local</span>/bigdata</div><div class="line">mkdir -p /usr/<span class="built_in">local</span>/bigdata/cdh/5</div><div class="line">mv  cloudera-cdh5.7.4/RPMS  cdh/5  <span class="comment">#移动之前下载的rpm包到cdh/5中</span></div></pre></td></tr></table></figure>
<p>搭建web服务器参考：<a href="http://blog.csdn.net/wenwenxiong/article/details/50499134" target="_blank" rel="external">Centos7安装apache web服务器</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">yum install httpd apr apr-util  <span class="comment">#重新安装httpd和apr、apr-util，</span></div><div class="line">yum install httpd-manual mod_ssl mod_perl mod_auth_mysql  <span class="comment">#Apache扩展模块</span></div><div class="line">systemctl start httpd.service  <span class="comment">#启动web服务器</span></div><div class="line">systemctl <span class="built_in">enable</span> httpd.service   <span class="comment">#设置成开机自动启动</span></div><div class="line">ln <span class="_">-s</span> /usr/<span class="built_in">local</span>/bigdata/cdh/ /var/www/html/ </div><div class="line"> <span class="comment">#建立软连接到hadoop各软件，apache的web项目默认路径为/var/www/html/</span></div></pre></td></tr></table></figure>
<p>建立软连接后，就能在<code>/var/www/html</code>下面看到cdh的目录了。<br><img src="/images/cluster/1509604618950.png" alt="Alt text"><br>然后从windows主机中，输入masterip地址，就能访问cdh中的文件目录<br><img src="/images/cluster/1509604693949.png" alt="Alt text"><br>这下本地已经拥有所有安装hadoop的软件了，可以断开网络安装hadoop了。<br>搭建web服务器才能让局域网的其他机器通过http方式访问到master中的安装包。</p>
<h2 id="3-在master上安装yum仓库。"><a href="#3-在master上安装yum仓库。" class="headerlink" title="3. 在master上安装yum仓库。"></a>3. 在master上安装yum仓库。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/bigdata/cdh/5</div><div class="line">createrepo .    #在该目录下创建yum的元数据文件，</div></pre></td></tr></table></figure>
<p>生成文件repodata的文件，如下：<br><img src="/images/cluster/1509606198662.png" alt="Alt text"></p>
<p>回到最开始配置yum 的cloudera的url路径</p>
<p>修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/yum.repos.d/CentOS-Cloudera.repo</div></pre></td></tr></table></figure>
<p>修改后如下:<br><img src="/images/cluster/1509611499617.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">yum update #更新</div><div class="line">yum clean all  #清理缓存</div><div class="line">yum makecache #建立新缓存</div><div class="line">yum install hadoop #安装hadoop</div></pre></td></tr></table></figure>
<p><img src="/images/cluster/1509611188723.png" alt="Alt text"><br>安装时要求nc 和psmisc<br>所以先安装这两个再安装hadoop</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install nc psmisc</div></pre></td></tr></table></figure>
<p> 很快就能安装成功。<br><img src="/images/cluster/1509611332250.png" alt="Alt text"></p>
<p>一旦您确认了内部镜像的工作，您就可以将这个修改后的repo文件分发给任何可以连接到存储库服务器的系统。这些系统现在可以在没有网络访问的情况下从本地存储库中安装CDH。遵循安装最新的CDH 5版本的说明，从步骤2开始(您已经完成了第1步)。</p>
<h2 id="4-在savler上配置yum"><a href="#4-在savler上配置yum" class="headerlink" title="4. 在savler上配置yum"></a>4. 在savler上配置yum</h2><p>把 <code>/etc/yum.repos.d/CentOS-Cloudera.repo</code>传输给两台savler，采用scp，首先需要在三台机器上都执行  <code>yum install openssh-clients -y</code><br>在master上执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">scp /etc/yum.repos.d/CentOS-Cloudera.repo  root@192.168.2.5:/etc/yum.repos.d/                                             </div><div class="line"> </div><div class="line">scp /etc/yum.repos.d/CentOS-Cloudera.repo  root@192.168.2.6:/etc/yum.repos.d/</div></pre></td></tr></table></figure>
<h2 id="5-其他设置"><a href="#5-其他设置" class="headerlink" title="5. 其他设置"></a>5. 其他设置</h2><h3 id="ntp同步时间"><a href="#ntp同步时间" class="headerlink" title="ntp同步时间"></a>ntp同步时间</h3><p>实现三台机器时间保持一致，采用ntp进行同步。主要有以下几步：<br>参考：<a href="https://www.cloudera.com/documentation/enterprise/5-4-x/topics/install_cdh_enable_ntp.html" target="_blank" rel="external">ntp时间同步</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">yum install ntp  #安装ntp</div><div class="line">systemctl start ntpd  #启动ntp</div><div class="line">systemctl enable ntpd #开机自启动ntp</div><div class="line">ntpdate -u cn.ntp.org.cn #同步到中国时间服务器，可能出error，多试几次。</div><div class="line">hwclock --systohc  #同步到系统时间</div></pre></td></tr></table></figure>
<h3 id="配置network的hostname"><a href="#配置network的hostname" class="headerlink" title="配置network的hostname"></a>配置network的hostname</h3><p>在所有机器中添加/etc/hosts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</div><div class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</div><div class="line">192.168.2.4 hadoop-master</div><div class="line">192.168.2.5 hadoop-slaver1</div><div class="line">192.168.2.6 hadoop-slaver6</div></pre></td></tr></table></figure>
<h3 id="master中安装mysql"><a href="#master中安装mysql" class="headerlink" title="master中安装mysql"></a>master中安装mysql</h3><p>参考：<a href="https://www.cnblogs.com/starof/p/4680083.html" target="_blank" rel="external">https://www.cnblogs.com/starof/p/4680083.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[~] wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</div><div class="line">[~] rpm -ivh mysql-community-release-el7-5.noarch.rpm</div><div class="line">[~] yum install mysql-community-server</div></pre></td></tr></table></figure>
<p>启动和开机自启动配置</p>
<p>安装成功后启动mysql服务，设置开机自启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl restart mysqld.service</div><div class="line">systemctl enable mysqld.service</div></pre></td></tr></table></figure>
<p>进入mysql配置密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  mysql -u root</div><div class="line">mysql&gt; set password for &apos;root&apos;@&apos;localhost&apos; =password(&apos;password&apos;);</div></pre></td></tr></table></figure>
<p>mysql配置文件为<code>/etc/my.cnf</code><br>最后加上编码配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mysql]</div><div class="line">default-character-set =utf8</div></pre></td></tr></table></figure>
<p>这里的字符编码必须和<code>/usr/share/mysql/charsets/Index.xml</code>中一致。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍vm安装centos7系统最小设置，采用3个虚拟机搭建大数据集群。安装chd5.7.4版本。&lt;br&gt;参考网址：&lt;a href=&quot;https://www.cloudera.com/documentation/enterprise/5-7-x/topics/cdh_ig_command_line.html&quot;&gt;https://www.cloudera.com/documentation/enterprise/5-7-x/topics/cdh_ig_command_line.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="yum" scheme="http://yoursite.com/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop集群搭建(一)--环境配置</title>
    <link href="http://yoursite.com/2017/12/14/Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA(%E4%B8%80)--%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/12/14/Hadoop集群搭建(一)--环境配置/</id>
    <published>2017-12-14T15:53:44.166Z</published>
    <updated>2017-12-14T18:49:55.369Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍vm安装centos7系统最小设置，采用3个虚拟机搭建大数据集群。CDH版本的hdfs，hadoop，Hbase搭建。<br><a id="more"></a></p>
<p>环境：centos7–三台<br>软件版本:CDH5.7.4</p>
<h2 id="1、vm安装centos7系统"><a href="#1、vm安装centos7系统" class="headerlink" title="1、vm安装centos7系统"></a>1、vm安装centos7系统</h2><p>不详细描述，唯一注意选择安装软件时，采用最小环境min,节约虚拟机容量</p>
<h2 id="2、设置Linux"><a href="#2、设置Linux" class="headerlink" title="2、设置Linux"></a>2、设置Linux</h2><h3 id="2-1、设置IP并上网"><a href="#2-1、设置IP并上网" class="headerlink" title="2.1、设置IP并上网"></a>2.1、设置IP并上网</h3><p>参考救命博客 : <a href="http://blog.csdn.net/u013066244/article/details/61655788" target="_blank" rel="external">虚拟机中的CentOS 7设置固定IP连接最理想的配置</a><br>前期走了多少弯路不再叙述。。。</p>
<h3 id="2-2、关闭防火墙"><a href="#2-2、关闭防火墙" class="headerlink" title="2.2、关闭防火墙"></a>2.2、关闭防火墙</h3><p>只需两步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl stop firewalld #关闭防火墙</div><div class="line">systemctl disable firewalld.service  #开机后也禁用防火墙</div></pre></td></tr></table></figure>
<h4 id="2-2-1、防火墙的其他命令"><a href="#2-2-1、防火墙的其他命令" class="headerlink" title="2.2.1、防火墙的其他命令"></a>2.2.1、防火墙的其他命令</h4><p><strong>这一步可以跳过</strong><br>1、firewalld的基本使用<br>启动： <code>systemctl start firewalld</code><br>查看状态： <code>systemctl status firewalld</code><br>停止： <code>systemctl stop firewalld</code><br>开机禁用： <code>systemctl disable firewalld</code></p>
<p>2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。<br>启动一个服务：<code>systemctl start firewalld.service</code><br>关闭一个服务：<code>systemctl stop firewalld.service</code><br>重启一个服务：<code>systemctl restart firewalld.service</code><br>显示一个服务的状态：<code>systemctl status firewalld.service</code><br>在开机时启用一个服务：<code>systemctl enable firewalld.service</code><br>在开机时禁用一个服务：<code>systemctl disable firewalld.service</code><br>查看服务是否开机启动：<code>systemctl is-enabled firewalld.service</code><br>查看已启动的服务列表：<code>systemctl list-unit-files|grep enabled</code><br>查看启动失败的服务列表：<code>systemctl --failed</code></p>
<p>3.配置firewalld-cmd</p>
<p>查看版本： <code>firewall-cmd --version</code><br>查看帮助： <code>firewall-cmd --help</code><br>显示状态： <code>firewall-cmd --state</code><br>查看所有打开的端口： <code>firewall-cmd --zone=public --list-ports</code><br>更新防火墙规则： <code>firewall-cmd --reload</code><br>查看区域信息:  <code>firewall-cmd --get-active-zones</code><br>查看指定接口所属区域： <code>firewall-cmd --get-zone-of-interface=eth0</code><br>拒绝所有包：<code>firewall-cmd --panic-on</code><br>取消拒绝状态： <code>firewall-cmd --panic-off</code><br>查看是否拒绝： <code>firewall-cmd --query-panic</code></p>
<p>那怎么开启一个端口呢<br>添加<br><code>firewall-cmd --zone=public --add-port=80/tcp --permanent</code>    （–permanent永久生效，没有此参数重启后失效）<br>重新载入</p>
<p><code>firewall-cmd --reload</code></p>
<p>查看<br><code>firewall-cmd --zone= public --query-port=80/tcp</code><br>删除<br><code>firewall-cmd --zone= public --remove-port=80/tcp --permanent</code></p>
<h3 id="2-3、关闭selinux"><a href="#2-3、关闭selinux" class="headerlink" title="2.3、关闭selinux"></a>2.3、关闭selinux</h3><p>该服务我也不清楚有什么用，好像比较麻烦和很多软件冲突，许多教材里都建议关闭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysconfig/selinux #进入该文件</div><div class="line"> 设置该值为：SELINUX=disabled</div></pre></td></tr></table></figure></p>
<p>重启即可。<br>查看SELinux状态：<br>1、<code>/usr/sbin/sestatus -v</code><br><code>##如果SELinux status参数为enabled即为开启状态,disabled关闭状态</code><br><code>##/usr/sbin/sestatus -v   SELinux status:                 disabled</code></p>
<h3 id="2-4、修改主机名"><a href="#2-4、修改主机名" class="headerlink" title="2.4、修改主机名"></a>2.4、修改主机名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vi /etc/hostname  #进入修改名字为hadoop-master，或者使用命令hostnamectl set-hostname hadoop-master</div><div class="line">hostnamectl status #查看主机名状态</div></pre></td></tr></table></figure>
<h3 id="2-5、免密登录"><a href="#2-5、免密登录" class="headerlink" title="2.5、免密登录"></a>2.5、免密登录</h3><p>命令<code>ssh-keygen -t rsa</code>然后四个回车即可。<br><img src="/images/cluster/1508915703219.png" alt="Alt text"><br>拷贝到远程服务器中<br><code>ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.2.4</code></p>
<h2 id="3、安装JDK"><a href="#3、安装JDK" class="headerlink" title="3、安装JDK"></a>3、安装JDK</h2><p>我这里下载好的jdk8安装，先上传安装包到/usr/local/lib</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/lib   #进入到安装目录</div><div class="line">tar -zxvf jdk-8u102-linux-x64.gz  #解压jdk安装包</div><div class="line">mv jdk1.8.0_102 jdk8  #为了方便，改一个名字</div><div class="line">vi /etc/profile  #配置环境变量，添加如下语句</div><div class="line">  export JAVA_HOME=/usr/local/lib/jdk8</div><div class="line">  export  CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div><div class="line">  export PATH=$JAVA_HOME/bin:$PATH</div><div class="line"></div><div class="line">source /etc/profile #配置文件立即生效</div><div class="line">java -version  #测试是否安装正确</div></pre></td></tr></table></figure>
<h2 id="4、克隆虚拟机2台机器"><a href="#4、克隆虚拟机2台机器" class="headerlink" title="4、克隆虚拟机2台机器"></a>4、克隆虚拟机2台机器</h2><p>克隆slaver1，slaver2作为工作节点，<br>右键虚拟机–&gt;管理–&gt;克隆–&gt;然后进行下一步设置<br>由于克隆出来的所以ip地址和物理地址和master保持一致的，故需要修改。<br><img src="/images/cluster/1508922526360.png" alt="Alt text"><br>生成物理地址，记录下来<br>在slaver中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vi /etc/sysconfig/network-scripts/ifcfg-eno16777736 #vi这个文件添加</div><div class="line">     MACADDR=00:50:56:34:fb:77</div><div class="line">     IPADDR=192.168.2.5</div><div class="line">vi /etc/hostname #修改主机名</div><div class="line">     hadoop-slaver1</div></pre></td></tr></table></figure>
<p>重启，同理savler2也这样设置，主机名修改为hadoop-slaver2<br>修改后slaver1的配置为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">TYPE=Ethernet</div><div class="line">BOOTPROTO=static</div><div class="line">DEFROUTE=yes</div><div class="line">PEERDNS=yes</div><div class="line">PEERROUTES=yes</div><div class="line">IPV4_FAILURE_FATAL=no</div><div class="line">IPV6INIT=yes</div><div class="line">IPV6_AUTOCONF=yes</div><div class="line">IPV6_DEFROUTE=yes</div><div class="line">IPV6_PEERDNS=yes</div><div class="line">IPV6_PEERROUTES=yes</div><div class="line">IPV6_FAILURE_FATAL=no</div><div class="line">NAME=eno16777736</div><div class="line">UUID=6eb36a11-5639-4707-bee4-91b7b1e895af</div><div class="line">DEVICE=eno16777736</div><div class="line">MACADDR=00:50:56:34:fb:77</div><div class="line">DNS1=114.114.114.114</div><div class="line">IPADDR=192.168.2.5</div><div class="line">NETMASK=255.255.255.0</div><div class="line">GATEWAY=192.168.2.1</div><div class="line">ONBOOT=yes</div></pre></td></tr></table></figure>
<h2 id="5、三台机器之间采用ssh相互免密登录"><a href="#5、三台机器之间采用ssh相互免密登录" class="headerlink" title="5、三台机器之间采用ssh相互免密登录"></a>5、三台机器之间采用ssh相互免密登录</h2><p>多个主机之间共享ssh连接登录方法：<a href="http://blog.csdn.net/timchen525/article/details/75579611" target="_blank" rel="external">集群间多台机器SSH免密码登录（两种方法实现）</a><br>master中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa #生成秘钥，刚才已经生成过了就无需执行</div><div class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.2.5#公钥发送到slaver1</div><div class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.2.6#公钥发送到slaver2</div></pre></td></tr></table></figure>
<p>都选着yes这样，master就能免密登录slaver1和slaver2<br>测试：<br><img src="/images/cluster/1508924793140.png" alt="Alt text"><br>无需输入密码即可登录另一台主机。</p>
<p>slaver1执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa #生成秘钥，刚才已经生成过了就无需执行</div><div class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.2.4#公钥发送到master</div><div class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.2.6#公钥发送到slaver2</div></pre></td></tr></table></figure></p>
<p>slaver2执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa #生成秘钥，刚才已经生成过了就无需执行</div><div class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.2.4#公钥发送到master</div><div class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.2.5#公钥发送到slaver1</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍vm安装centos7系统最小设置，采用3个虚拟机搭建大数据集群。CDH版本的hdfs，hadoop，Hbase搭建。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Python3的文件操作</title>
    <link href="http://yoursite.com/2017/05/18/python/python3%20%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/05/18/python/python3 的文件操作/</id>
    <published>2017-05-18T05:01:44.423Z</published>
    <updated>2017-05-18T06:37:31.526Z</updated>
    
    <content type="html"><![CDATA[<p>本人一直对各种语言的文件操作有阴影(以前学c语言留下来的后遗症),_(:з」∠)_所以对python中的文件操作进行记录一遍后续查找。<br><a id="more"></a></p>
<h1 id="python3-的文件操作"><a href="#python3-的文件操作" class="headerlink" title="python3 的文件操作"></a>python3 的文件操作</h1><h2 id="1、读取文件操作"><a href="#1、读取文件操作" class="headerlink" title="1、读取文件操作"></a>1、读取文件操作</h2><h3 id="1-1、最基本操作"><a href="#1-1、最基本操作" class="headerlink" title="1.1、最基本操作"></a>1.1、最基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f = open(path ,&apos;r&apos;)</div><div class="line">f.read()#就能得到文本中的字符</div><div class="line">f.close()#注意文件读取完后必须关闭，这样才能节省内存消耗</div></pre></td></tr></table></figure>
<h4 id="1-1-1、打开文件时需要的参数。"><a href="#1-1-1、打开文件时需要的参数。" class="headerlink" title="1.1.1、打开文件时需要的参数。"></a>1.1.1、打开文件时需要的参数。</h4><p>1、一般来时只需要path文件路径，和读取方式<br>2、但是也会添加以什么编码读入encoding,eg:<code>open(path,&#39;r&#39;,encoding=&#39;utf-8&#39;)</code><br>3、遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：<br> <code>f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;)</code></p>
<h3 id="1-2、with自动调用关闭文件方法close"><a href="#1-2、with自动调用关闭文件方法close" class="headerlink" title="1.2、with自动调用关闭文件方法close()"></a>1.2、with自动调用关闭文件方法close()</h3><p>采用with就无需关闭文件了with会自动帮我们关闭文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">with open(path ,&apos;r&apos;) as f:</div><div class="line">	f.read()</div></pre></td></tr></table></figure></p>
<h3 id="1-3、读取部分内容，read-size-readline"><a href="#1-3、读取部分内容，read-size-readline" class="headerlink" title="1.3、读取部分内容，read(size),readline()"></a>1.3、读取部分内容，read(size),readline()</h3><p>read(size)：采用该方法循环读取一定字节的内容，这样内存不容易爆炸<br>readlines():对文本内容循环一行一行的读取。然后遍历</p>
<h3 id="1-4、写文件"><a href="#1-4、写文件" class="headerlink" title="1.4、写文件"></a>1.4、写文件</h3><p>读写文件采用with是一个好习惯。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f:</div><div class="line">    f.write(&apos;Hello, world!&apos;)</div></pre></td></tr></table></figure></p>
<h3 id="1-5、读取方式总结"><a href="#1-5、读取方式总结" class="headerlink" title="1.5、读取方式总结"></a>1.5、读取方式总结</h3><p>要么读，要么写，代码简单，性能高</p>
<p>所以一般只需要用r, rb, w, wb就够了</p>
<ul>
<li><strong>r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</strong></li>
<li><p><strong>rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</strong></p>
</li>
<li><p>r+ 打开一个文件用于读写。文件指针将会放在文件的开头。</p>
</li>
<li><p>rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</p>
</li>
<li><p><strong>w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</strong></p>
</li>
<li><p><strong>wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</strong></p>
</li>
<li><p>w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</p>
</li>
<li><p>wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</p>
</li>
<li><p>a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</p>
</li>
<li><p>ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</p>
</li>
<li><p>a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</p>
</li>
<li><p>ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</p>
</li>
</ul>
<h2 id="2、文件操作"><a href="#2、文件操作" class="headerlink" title="2、文件操作"></a>2、文件操作</h2><h3 id="2-1-1、文件路径分割"><a href="#2-1-1、文件路径分割" class="headerlink" title="2.1.1、文件路径分割"></a>2.1.1、文件路径分割</h3><p>通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.split(&apos;/Users/michael/testdir/file.txt&apos;)</div><div class="line">(&apos;/Users/michael/testdir&apos;, &apos;file.txt&apos;)</div></pre></td></tr></table></figure>
<h3 id="2-1-2、文件重命名和删除"><a href="#2-1-2、文件重命名和删除" class="headerlink" title="2.1.2、文件重命名和删除"></a>2.1.2、文件重命名和删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 对文件重命名:</div><div class="line">&gt;&gt;&gt; os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)</div><div class="line"># 删掉文件:</div><div class="line">&gt;&gt;&gt; os.remove(&apos;test.py&apos;)</div></pre></td></tr></table></figure>
<h3 id="2-1-3、列出所有py文件，一行代码"><a href="#2-1-3、列出所有py文件，一行代码" class="headerlink" title="2.1.3、列出所有py文件，一行代码"></a>2.1.3、列出所有py文件，一行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;]</div><div class="line">[&apos;apis.py&apos;, &apos;config.py&apos;, &apos;models.py&apos;, &apos;pymonitor.py&apos;, &apos;test_db.py&apos;, &apos;urls.py&apos;, &apos;wsgiapp.py&apos;]</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人一直对各种语言的文件操作有阴影(以前学c语言留下来的后遗症),_(:з」∠)_所以对python中的文件操作进行记录一遍后续查找。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="文件操作" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python中的类</title>
    <link href="http://yoursite.com/2017/05/18/python/Python%E4%B8%AD%E7%9A%84%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/05/18/python/Python中的类/</id>
    <published>2017-05-18T04:12:20.887Z</published>
    <updated>2017-05-18T06:38:56.607Z</updated>
    
    <content type="html"><![CDATA[<p>本文也是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external">廖雪峰的python教程</a>中的知识总结。<br><a id="more"></a></p>
<h3 id="1、访问权限"><a href="#1、访问权限" class="headerlink" title="1、访问权限"></a>1、访问权限</h3><h4 id="1-1、直接访问公用的属性"><a href="#1-1、直接访问公用的属性" class="headerlink" title="1.1、直接访问公用的属性"></a>1.1、直接访问公用的属性</h4><p>命名直接采用字符串命名就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Student:</div><div class="line">	def __init__(self, name, score):</div><div class="line">		self.name = name</div><div class="line">		self.score = score</div><div class="line">	def printStu(self):</div><div class="line">		print(&apos;name is :&apos;, self.name, &apos;my score is:&apos;, self.score)</div></pre></td></tr></table></figure>
<p>外部可直接访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stu = Student(&apos;csg&apos;,&apos;100&apos;)</div><div class="line">&gt;&gt;&gt;stu.name</div><div class="line">csg</div></pre></td></tr></table></figure>
<h4 id="1-2、私有属性的设置"><a href="#1-2、私有属性的设置" class="headerlink" title="1.2、私有属性的设置"></a>1.2、私有属性的设置</h4><p>让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 98)</div><div class="line">&gt;&gt;&gt; bart.__name</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;__name&apos;</div></pre></td></tr></table></figure>
<p>所以要获取或修改里面成员的数据就得为类增加<code>get_name(self)</code>和<code>set_name(self,name)</code>的方法</p>
<p><strong>注意：</strong></p>
<ul>
<li>变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__、__score__</code>这样的变量名。</li>
<li>一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”</li>
<li>不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量。但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。</li>
<li>特别注意以下写法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 98)</div><div class="line">&gt;&gt;&gt; bart.get_name()</div><div class="line">&apos;Bart Simpson&apos;</div><div class="line">&gt;&gt;&gt; bart.__name = &apos;New Name&apos; # 设置__name变量！</div><div class="line">&gt;&gt;&gt; bart.__name</div><div class="line">&apos;New Name&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量不是一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给bart新增了一个<code>__name</code>变量。<br><strong>总结：</strong></p>
<ul>
<li>开头有双下划线    ====》》  私有变量（外部不可访问）</li>
<li>开头和结尾都有双下划线  ====》》 特殊变量（外部可访问）</li>
<li>开头单下划线  ====》》  视为私有变量（不建议访问）<br>若要访问，可在class内部单独添加函数。<h3 id="2、静态语言-vs-动态语言"><a href="#2、静态语言-vs-动态语言" class="headerlink" title="2、静态语言 vs 动态语言"></a>2、静态语言 vs 动态语言</h3></li>
</ul>
<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Timer(object):</div><div class="line">    def run(self):</div><div class="line">        print(&apos;Start...&apos;)</div></pre></td></tr></table></figure>
<p>动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<h3 id="3、获取类中的所有属性和方法—dir-object"><a href="#3、获取类中的所有属性和方法—dir-object" class="headerlink" title="3、获取类中的所有属性和方法—dir(object)"></a>3、获取类中的所有属性和方法—dir(object)</h3><p>返回一个包含字符串的list。<br>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; len(&apos;ABC&apos;)</div><div class="line">3</div><div class="line">&gt;&gt;&gt; &apos;ABC&apos;.__len__()</div><div class="line">3</div></pre></td></tr></table></figure>
<p>我们自己写的类，如果也想用len(myObj)的话，就自己写一个<strong>len</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class MyDog(object):</div><div class="line">...     def __len__(self):</div><div class="line">...         return 100</div><div class="line">...</div><div class="line">&gt;&gt;&gt; dog = MyDog()</div><div class="line">&gt;&gt;&gt; len(dog)</div><div class="line">100</div></pre></td></tr></table></figure>
<p>仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态，（一般不这么用，除非不知道类中的内容）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class MyObject(object):</div><div class="line">...     def __init__(self):</div><div class="line">...         self.x = 9</div><div class="line">...     def power(self):</div><div class="line">...         return self.x * self.x</div><div class="line">...</div><div class="line">&gt;&gt;&gt; obj = MyObject()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？</div><div class="line">True</div><div class="line">&gt;&gt;&gt; obj.x</div><div class="line">9</div><div class="line">&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？</div><div class="line">False</div><div class="line">&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;</div><div class="line">&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？</div><div class="line">True</div><div class="line">&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;</div><div class="line">19</div><div class="line">&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;</div><div class="line">19</div></pre></td></tr></table></figure>
<p>如果试图获取不存在的属性，会抛出AttributeError的错误,可以传入一个default参数，如果属性不存在，就返回默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; getattr(obj, &apos;z&apos;, 404) # 获取属性&apos;z&apos;，如果不存在，返回默认值404</div><div class="line">404</div></pre></td></tr></table></figure>
<h2 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h2><h3 id="4、使用-slots"><a href="#4、使用-slots" class="headerlink" title="4、使用__slots__"></a>4、使用<code>__slots__</code></h3><p>python属于动态语言，能够在定义类后，随意绑定某个实例的属性和方法，eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>1、实例绑定一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = Student()</div><div class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 动态给实例绑定一个属性</div><div class="line">&gt;&gt;&gt; print(s.name)</div><div class="line">Michael</div></pre></td></tr></table></figure>
<p>2、实例绑定一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法</div><div class="line">...     self.age = age</div><div class="line">...</div><div class="line">&gt;&gt;&gt; from types import MethodType</div><div class="line">&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法</div><div class="line">&gt;&gt;&gt; s.set_age(25) # 调用实例方法</div><div class="line">&gt;&gt;&gt; s.age # 测试结果</div><div class="line">25</div></pre></td></tr></table></figure>
<p>3、给实例绑定的方法对另一个实例不起作用，也就是如下错误，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s2 = Student() # 创建新的实例</div><div class="line">&gt;&gt;&gt; s2.set_age(25) # 尝试调用方法</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;set_age&apos;</div></pre></td></tr></table></figure>
<p>4、所以要给所有实例绑定方法，就得采用类class的方法绑定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Student.set_score = set_score</div></pre></td></tr></table></figure>
<p><strong>重点：</strong>通常情况下我们想要限制实例的属性和方法怎么办？比如，只允许对Student实例添加name和age属性。这时就用到我们的特殊变量<code>__slots__</code>,来限制class<strong>实例</strong>（特别注意只是限制实例不限制类本身）中添加的属性和方法 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">    __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称</div></pre></td></tr></table></figure>
<p>实验结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = Student() # 创建新的实例</div><div class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;</div><div class="line">&gt;&gt;&gt; s.age = 25 # 绑定属性&apos;age&apos;</div><div class="line">&gt;&gt;&gt; s.score = 99 # 绑定属性&apos;score&apos;</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos;</div></pre></td></tr></table></figure>
<p><font color="red"><strong>特别注意：</strong></font></p>
<ul>
<li><code>__slots__</code>定义的属性仅对<strong>当前类的<font color="red">实例</font></strong>起作用，对<strong>继承的子类是不起作用的</strong>，而且对类的本身也不起作用，</li>
<li>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。 <code>__slots__ = ()</code>  # 可以将父类的 <code>__slots__</code> 单独继承过来<br>例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Student:</div><div class="line">	__slots__ = (&apos;name&apos;, &apos;age&apos;)</div><div class="line">	</div><div class="line">	def __init__(self, name):</div><div class="line">		self.name = name</div><div class="line">		# self.sex = name #这一句报错，</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">	s1 = Student(&apos;男&apos;)</div><div class="line">	s1.name = &apos;csg&apos;</div><div class="line">	s1.age = 26</div><div class="line">	# s1.score = 30 # 这一句报错，因为限制实例的属性</div><div class="line">	Student.score = 35 #成功能直接给类添加属性，但是这样该属性对于实例来说只能可读，而且都一样</div><div class="line">	print(s1.score)  #35</div></pre></td></tr></table></figure>
<h3 id="5、-property的使用"><a href="#5、-property的使用" class="headerlink" title="5、@property的使用"></a>5、@property的使用</h3><p>@property装饰器就是负责把一个方法变成属性调用的：@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class Student:</div><div class="line">	</div><div class="line">	def set_sex(self,sex):</div><div class="line">		self._sex=sex</div><div class="line">	</div><div class="line">	def get_sex(self):</div><div class="line">		return self._sex</div><div class="line">	</div><div class="line">	@property</div><div class="line">	def name(self): #类似get</div><div class="line">		print(&apos;use name.property functiong ---&apos;)</div><div class="line">		return self._name</div><div class="line">	</div><div class="line">	@name.setter</div><div class="line">	def name(self, name): #类似set</div><div class="line">		print(&apos;use name.setter functiong ---&apos;)</div><div class="line">		self._name = name</div><div class="line"></div><div class="line">	@property</div><div class="line">	def score(self):</div><div class="line">		return self._score</div><div class="line">	</div><div class="line">	@score.setter</div><div class="line">	def score(self,value):</div><div class="line">		if not isinstance(value, int):</div><div class="line">			raise ValueError(&apos;score must be an integer!&apos;)</div><div class="line">		if value &lt; 0 or value &gt; 100:</div><div class="line">			raise ValueError(&apos;score must between 0 ~ 100!&apos;)</div><div class="line">		self._score = value</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">	</div><div class="line">	s1 = Student()</div><div class="line">	s1.set_sex(&apos;男男男男男男&apos;)</div><div class="line">	print(s1.get_sex())</div><div class="line">	s1.name=&apos;csg&apos; #就可以使用&quot;.&quot;来操作类中的函数了。</div><div class="line">	#s1.name(&apos;csl&apos;) #再来把name方法调用就会出错，因为装饰器已经把name变成了一个属性，属性后面再加括号()什么鬼</div><div class="line">	print(s1.name)</div><div class="line">	# s1.score=80 #对于socre来说，分数没有@score.setter方法，只能可读</div></pre></td></tr></table></figure>
<p><strong>彩蛋：</strong><br>在进行属性访问控制定义的时候你可能会很容易的引起一个错误。考虑下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def __setattr__(self, name, value):</div><div class="line">    self.name = value</div></pre></td></tr></table></figure>
<p>每当属性被赋值的时候，<code>__setattr__()</code> 会被调用，这样就造成了递归调用。</p>
<p>这意味着调用 <code>self.__setattr__(&#39;name&#39;, value)</code> 时每次方法都会调用自己。这样会造成程序崩溃。修改成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def __setattr__(self, name, value):</div><div class="line">    self.__dict__[name] = value  #给类中的属性名分配值，定制特有属性</div><div class="line">即可。</div></pre></td></tr></table></figure>
<h3 id="6、python的多重继承MaxIn，"><a href="#6、python的多重继承MaxIn，" class="headerlink" title="6、python的多重继承MaxIn，"></a>6、python的多重继承MaxIn，</h3><p>python和java不同，java属于单继承，只能有一个父类，而python却可以拥有几个父类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Person(Teacher, Woman)：</div><div class="line">	pass</div></pre></td></tr></table></figure></p>
<h3 id="7、定制类"><a href="#7、定制类" class="headerlink" title="7、定制类"></a>7、定制类</h3><h4 id="7-1定制打印输出-str-和-repr"><a href="#7-1定制打印输出-str-和-repr" class="headerlink" title="7.1定制打印输出__str__()和__repr__()"></a>7.1定制打印输出<code>__str__()</code>和<code>__repr__()</code></h4><p>打印某个类的时候，出现的输出结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(Student(&apos;Michael&apos;))</div><div class="line">&lt;__main__.Student object at 0x109afb190&gt;</div></pre></td></tr></table></figure></p>
<p>需要打印好看，需在原类中重写<code>__str__(self)</code>方法，这样打印就会按照自己的返回结果了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def __str__(self):</div><div class="line">         return &apos;Student object (name: %s)&apos; % self.name</div><div class="line">&gt;&gt;&gt; print(Student(&apos;Michael&apos;))#再次打印，就成了我们定义的名字</div><div class="line">Student object (name: Michael)</div></pre></td></tr></table></figure>
<p>注意：<br>虽然定义了<code>__str__()</code>若此时直接输出也是显示类的内存地址，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;Student(&apos;Michael&apos;)</div><div class="line">&lt;__main__.Student object at 0x109afb310&gt;</div></pre></td></tr></table></figure></p>
<p>因为直接输出是调用的<code>__repr__()</code>方式<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。解决办法：再定一个<code>__repr()__</code>即可，因为和str中输出一致，可采用简便方式如下添加：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__repr__ = __str__</div></pre></td></tr></table></figure></p>
<h4 id="7、2定制迭代-iter"><a href="#7、2定制迭代-iter" class="headerlink" title="7、2定制迭代__iter__()"></a>7、2定制迭代<code>__iter__()</code></h4><p>如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个<code>__iter__(</code>)方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。<br>斐波那契类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Fib(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.a, self.b = 0, 1 # 初始化两个计数器a，b</div><div class="line"></div><div class="line">    def __iter__(self):</div><div class="line">        return self # 实例本身就是迭代对象，故返回自己</div><div class="line"></div><div class="line">    def __next__(self):</div><div class="line">        self.a, self.b = self.b, self.a + self.b # 计算下一个值</div><div class="line">        if self.a &gt; 100000: # 退出循环的条件</div><div class="line">            raise StopIteration();</div><div class="line">        return self.a # 返回下一个值</div></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; for n in Fib():</div><div class="line">...     print(n)</div><div class="line">1</div><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure>
<h4 id="7-3、取得迭代中的具体某个值-getitem"><a href="#7-3、取得迭代中的具体某个值-getitem" class="headerlink" title="7.3、取得迭代中的具体某个值__getitem__"></a>7.3、取得迭代中的具体某个值<code>__getitem__</code></h4><p>上面的斐波那契数列想要取得某个索引的值，这一项当然不受是否有<code>__iter__</code>的影响，也就是不管类中是否有<code>__iter__</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Fib(object):</div><div class="line">    def __getitem__(self, n):</div><div class="line">        a, b = 1, 1</div><div class="line">        for x in range(n):</div><div class="line">            a, b = b, a + b</div><div class="line">        return a</div></pre></td></tr></table></figure></p>
<p>取值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; f = Fib()</div><div class="line">&gt;&gt;&gt; f[0]</div><div class="line">1</div><div class="line">&gt;&gt;&gt; f[1]</div><div class="line">1</div><div class="line">&gt;&gt;&gt; f[2]</div><div class="line">2</div></pre></td></tr></table></figure></p>
<p>当然目前这个尚未对list中切片处理，比如传入参数为f[1:5]就会报错。要实现就必须做各种判断，可参考：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319098638265527beb24f7840aa97de564ccc7f20f6000#0" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319098638265527beb24f7840aa97de564ccc7f20f6000#0</a></p>
<h4 id="7-4动态返回一个属性-getattr"><a href="#7-4动态返回一个属性-getattr" class="headerlink" title="7.4动态返回一个属性__getattr__"></a>7.4动态返回一个属性<code>__getattr__</code></h4><p>当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.name = &apos;Michael&apos;</div></pre></td></tr></table></figure>
<p>调用时出错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = Student()</div><div class="line">&gt;&gt;&gt; print(s.name)</div><div class="line">Michael</div><div class="line">&gt;&gt;&gt; print(s.score)</div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos;</div></pre></td></tr></table></figure></p>
<p>此时就可以用类中的<code>__getattr__</code>动态的返回一个默认值，类中添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def __getattr__(self, attr):</div><div class="line">        if attr==&apos;score&apos;:</div><div class="line">            return 99</div></pre></td></tr></table></figure>
<p>再次调用时会返回99，Python解释器会试图调用<code>__getattr__(self, &#39;score&#39;)</code>来尝试获得属性，<br>，只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如name，不会在<code>__getattr__</code>中查找。<br>还能返回函数，只是在调用的时候<br>返回函数也是完全可以的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line"></div><div class="line">    def __getattr__(self, attr):</div><div class="line">        if attr==&apos;age&apos;:</div><div class="line">            return lambda: 25</div></pre></td></tr></table></figure>
<p>只是调用方式要变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s.age()</div><div class="line">25</div></pre></td></tr></table></figure>
<p><strong>注意: 只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如name，不会在<code>__getattr__</code>中查找。</strong></p>
<p>此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的<code>__getattr__</code>默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：</p>
<p>Rest的链式调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Chain(object):</div><div class="line"></div><div class="line">    def __init__(self, path=&apos;&apos;):</div><div class="line">        self._path = path</div><div class="line"></div><div class="line">    def __getattr__(self, path):</div><div class="line">        return Chain(&apos;%s/%s&apos; % (self._path, path))</div><div class="line"></div><div class="line">    def __str__(self):</div><div class="line">        return self._path</div><div class="line"></div><div class="line">    __repr__ = __str__</div></pre></td></tr></table></figure>
<p>试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; Chain().status.user.timeline.list</div><div class="line">&apos;/status/user/timeline/list&apos;</div></pre></td></tr></table></figure>
<h4 id="7-5对象调用自身-call"><a href="#7-5对象调用自身-call" class="headerlink" title="7.5对象调用自身__call__"></a>7.5对象调用自身<code>__call__</code></h4><p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的。</p>
<p>任何类，只需要定义一个<code>__call__</code>()方法，就可以直接对实例进行调用。请看示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">    def __init__(self, name):</div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    def __call__(self):</div><div class="line">        print(&apos;My name is %s.&apos; % self.name)</div></pre></td></tr></table></figure>
<p>调用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = Student(&apos;Michael&apos;)</div><div class="line">&gt;&gt;&gt; s() # self参数不要传入</div><div class="line">My name is Michael.</div></pre></td></tr></table></figure>
<p><code>__call__</code>()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<p>如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p>
<ul>
<li>callable(Object)函数，我们就可以判断一个对象是否是“可调用”对象。<h3 id="8、枚举类型"><a href="#8、枚举类型" class="headerlink" title="8、枚举类型"></a>8、枚举类型</h3>定义方法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Month = Enum(&apos;Month&apos;, (&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;))</div><div class="line">print(Month.Jan)</div><div class="line">for name, number in Month.__members__.items():</div><div class="line">	print(name, &apos;==&gt;&apos;, number, &apos;:&apos;, number.value)#value属性则是自动赋给成员的int常量，默认从1开始计数。</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="8-1、派生的枚举类-unique"><a href="#8-1、派生的枚举类-unique" class="headerlink" title="8.1、派生的枚举类@unique"></a>8.1、派生的枚举类@unique</h4><p>如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from enum import Enum, unique</div><div class="line">@unique</div><div class="line">class Weekday(Enum):</div><div class="line">    Sun = 0 # Sun的value被设定为0</div><div class="line">    Mon = 1</div><div class="line">    Tue = 2</div><div class="line">    Wed = 3</div><div class="line">    Thu = 4</div><div class="line">    Fri = 5</div><div class="line">    Sat = 6</div></pre></td></tr></table></figure>
<p>@unique装饰器可以帮助我们检查保证没有重复值。</p>
<h4 id="8-2、枚举的访问方法"><a href="#8-2、枚举的访问方法" class="headerlink" title="8.2、枚举的访问方法"></a>8.2、枚举的访问方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; day1 = Weekday.Mon</div><div class="line">&gt;&gt;&gt; print(day1)--------》直接知道属性</div><div class="line">Weekday.Mon</div><div class="line">&gt;&gt;&gt; print(Weekday[&apos;Tue&apos;])-----》属性名</div><div class="line">Weekday.Tue</div><div class="line">&gt;&gt;&gt; print(Weekday.Tue.value)-----》属性值</div><div class="line">2</div><div class="line">&gt;&gt;&gt; print(day1 == Weekday.Mon)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; print(day1 == Weekday.Tue)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; print(Weekday(1))------------》成员索引</div><div class="line">Weekday.Mon</div></pre></td></tr></table></figure>
<p>Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。</p>
<h3 id="9、元类的使用"><a href="#9、元类的使用" class="headerlink" title="9、元类的使用"></a>9、元类的使用</h3><h4 id="9-1、type-动态创建类"><a href="#9-1、type-动态创建类" class="headerlink" title="9.1、type()动态创建类"></a>9.1、type()动态创建类</h4><p>type()一般两个作用</p>
<ul>
<li>type()函数可以查看一个类型或变量的类型</li>
<li>type()函数可以创建出新的类型，也就是可以动态创建类无需定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-&gt;&gt;&gt; def fn(self, name=&apos;world&apos;): # 先定义函数</div><div class="line">...     print(&apos;Hello, %s.&apos; % name)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; Hello = type(&apos;Hello&apos;, (object,), dict(hello=fn)) # 创建Hello class</div><div class="line">&gt;&gt;&gt; h = Hello()</div><div class="line">&gt;&gt;&gt; h.hello()</div><div class="line">Hello, world.</div><div class="line">&gt;&gt;&gt; print(type(Hello))</div><div class="line">&lt;class &apos;type&apos;&gt;</div><div class="line">&gt;&gt;&gt; print(type(h))</div><div class="line">&lt;class &apos;__main__.Hello&apos;&gt;</div></pre></td></tr></table></figure>
<p>传入的三个参数</p>
<ol>
<li>class的名称；</li>
<li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了<strong>tuple的单元素写法；</strong></li>
<li>class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。<h4 id="9-2、metaclass创建修改类"><a href="#9-2、metaclass创建修改类" class="headerlink" title="9.2、metaclass创建修改类"></a>9.2、metaclass创建修改类</h4>修改类中的定义<br>声明自己的MyList类，在原本list类上添加add方法，<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class ListMetaclass(type):</div><div class="line">	def __new__(cls, name, bases, attrs):</div><div class="line">		attrs[&apos;add&apos;] = lambda self, x: self.append(x)</div><div class="line">		return type.__new__(cls, name, bases, attrs)</div><div class="line">#新生成的MyList类</div><div class="line">class MyList(list, metaclass=ListMetaclass):</div><div class="line">	pass</div></pre></td></tr></table></figure>
</li>
</ol>
<p>测试结果如下，普通的list类就没有add方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = MyList()</div><div class="line">&gt;&gt;&gt; L.add(1)</div><div class="line">&gt;&gt; L</div><div class="line">[1]</div></pre></td></tr></table></figure></p>
<p><code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。<br><code>__new__()</code>方法接收到的参数依次是：</p>
<ul>
<li>当前准备创建的类的对象；</li>
<li>类的名字；</li>
<li>类继承的父类集合；</li>
<li>类的方法集合。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文也是学习&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000&quot;&gt;廖雪峰的python教程&lt;/a&gt;中的知识总结。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="函数式编程" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python小记</title>
    <link href="http://yoursite.com/2017/05/16/python/python%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/05/16/python/python小记/</id>
    <published>2017-05-16T08:23:10.245Z</published>
    <updated>2017-05-18T06:37:48.644Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说：好记性不如烂笔头，所以对于很多细节知识点我个人喜欢记录下来，本篇博文主要是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external">廖雪峰的python教程</a>从中总结需要掌握的部分知识点，记录下来方便以后查询<br><a id="more"></a></p>
<h1 id="python小记"><a href="#python小记" class="headerlink" title="python小记"></a>python小记</h1><h3 id="1、简洁if语句"><a href="#1、简洁if语句" class="headerlink" title="1、简洁if语句"></a>1、简洁if语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> x:</div><div class="line">    print(<span class="string">'True'</span>)</div></pre></td></tr></table></figure>
<p>只要x是<strong>非零数值、非空字符串、非空list</strong>等，就判断为True，否则为False。</p>
<h3 id="2、print-使用"><a href="#2、print-使用" class="headerlink" title="2、print()使用"></a>2、print()使用</h3><p><strong>end，sep</strong>参数的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#输出HelloWorld,end=&apos;&apos;空字符，中间不换行</div><div class="line">print(&apos;hello&apos;,end=&apos;&apos;)</div><div class="line">print(&apos;world&apos;)</div><div class="line">#输出hello,world,csg-------&gt;中间由sep来分割的，不写默认分割符为空格。</div><div class="line">#print(&apos;hello&apos;,&apos;world&apos;,&apos;csg&apos;,sep=&apos;,&apos;)</div></pre></td></tr></table></figure></p>
<h3 id="3、dict的小记"><a href="#3、dict的小记" class="headerlink" title="3、dict的小记"></a>3、dict的小记</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dic = &#123;&apos;1&apos;: &apos;csg&apos;, &apos;2&apos;: &apos;csl&apos;&#125;</div><div class="line">print(dic[&apos;1&apos;])  # ----&gt;csg</div><div class="line">print(dic[&apos;3&apos;])  # ----&gt;报错</div><div class="line">print(dic.get(&apos;1&apos;))  # ----&gt;csg</div><div class="line">print(dic.get(&apos;3&apos;))#-----&gt;None，不报错</div><div class="line">print(dic.get(&apos;3&apos;, &apos;chen&apos;))#-----&gt;chen,若不存在就用chen代替，不报错</div></pre></td></tr></table></figure>
<p>采用get方法取值，就算没有也不会报错<br>字典常用方法：</p>
<ul>
<li>pop(key)删除某个键值</li>
<li><p>has_keys(x) 若字典中有x返回true</p>
</li>
<li><p>keys() 返回键的列表</p>
</li>
<li><p>values() 返回值的列表</p>
</li>
<li><p>dict.items() 返回tuples的列表。每个tuple有字典的dict的键和相应的值组成</p>
</li>
<li><p>clear() 删除词典的所有条目</p>
</li>
<li><p>copy() 返回字典的高层结构的拷贝，但不复制嵌入结构，而复制那些结构的引用。</p>
</li>
<li><p>update(x) 用字典x中的键/值对更新字典的内容。</p>
</li>
<li><p>get(x[,y]) 返回键x。若未找到返回None</p>
</li>
<li>radiansdict.setdefault(key, default=None)：和get()类似, 但如果键不已经存在于字典中，将会添加键并将值设为default，<br><strong>注意：</strong>dic.setdefault(‘4’, ‘wudi’)这样才对<br>dic.setdefault(‘4’, default = ‘wudi’)，报错：TypeError: setdefault() takes no keyword arguments<h3 id="4、set小记"><a href="#4、set小记" class="headerlink" title="4、set小记"></a>4、set小记</h3></li>
</ul>
<p>set数据类型类似于dict中的key的集合，不能重复，<br>    存放不可变对象，比如数字，字符串等，不能存放像list这样的可变对象，和dict中的key一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setTest = set([1,2,3,4,4])</div><div class="line">	print(setTest)# ---&gt;1，2,3,4</div></pre></td></tr></table></figure></p>
<h3 id="5、函数可以返回多个值"><a href="#5、函数可以返回多个值" class="headerlink" title="5、函数可以返回多个值"></a>5、函数可以返回多个值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import math</div><div class="line">def move(x, y, step, angle=0):</div><div class="line">    nx = x + step * math.cos(angle)</div><div class="line">    ny = y - step * math.sin(angle)</div><div class="line">    return nx, ny</div></pre></td></tr></table></figure>
<p><code>import math</code>语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。</p>
<p>然后，我们就可以同时获得返回值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</div><div class="line">&gt;&gt;&gt; print(x, y)</div><div class="line">151.96152422706632 70.0</div></pre></td></tr></table></figure>
<p>但其实这只是一种假象，Python函数返回的仍然是单一值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</div><div class="line">&gt;&gt;&gt; print(r)</div><div class="line">(151.96152422706632, 70.0)</div></pre></td></tr></table></figure>
<p>原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h3 id="6、函数的默认值传入"><a href="#6、函数的默认值传入" class="headerlink" title="6、函数的默认值传入"></a>6、函数的默认值传入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def function(x, y=2):# 这里的y如果只传入x一个参数，function(x)第二个参数默认为2	</div><div class="line">pass</div></pre></td></tr></table></figure>
<h3 id="7、迭代问题"><a href="#7、迭代问题" class="headerlink" title="7、迭代问题"></a>7、迭代问题</h3><h4 id="7-1，字典迭代"><a href="#7-1，字典迭代" class="headerlink" title="7.1，字典迭代"></a>7.1，字典迭代</h4><p>只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：<br>默认采用key来迭代<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</div><div class="line">&gt;&gt;&gt; for key in d:</div><div class="line">...     print(key)</div><div class="line">...</div><div class="line">a</div><div class="line">c</div><div class="line">b</div></pre></td></tr></table></figure></p>
<p>如果要迭代value，。如果要迭代value，可以用<code>for value in d.values()</code><br>同时迭代key，value采用<code>for k, v in d.items()</code>。</p>
<h4 id="7-2迭代下标"><a href="#7-2迭代下标" class="headerlink" title="7.2迭代下标"></a>7.2迭代下标</h4><p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的<strong>enumerate</strong>函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</div><div class="line">...     print(i, value)</div><div class="line">...</div><div class="line">0 A</div><div class="line">1 B</div><div class="line">2 C</div></pre></td></tr></table></figure>
<h3 id="8、列表生成式，list"><a href="#8、列表生成式，list" class="headerlink" title="8、列表生成式，list"></a>8、列表生成式，list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</div><div class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</div></pre></td></tr></table></figure>
<p>写列表生成式时，把要生成的元素<strong>x * x</strong>放到前面，后面跟<strong>for</strong>循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>
<p>for循环后面还可以加上<font color="red"><strong>if</strong></font>判断，这样我们就可以筛选出仅偶数的平方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</div><div class="line">[4, 16, 36, 64, 100]</div></pre></td></tr></table></figure>
<p>还可以使用两层循环，可以生成全排列：（三层和三层以上的就很少用了）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</div><div class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</div></pre></td></tr></table></figure></p>
<p>把list中的所有字符串变成小写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;]</div><div class="line">&gt;&gt;&gt; [s.lower() for s in L]</div><div class="line">[&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;]</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>这里并没有改变原来的L列表，而是从新生成了一个新的小写字母列表</p>
<h3 id="8、判断python中变量是不是字符串，采用isinstance"><a href="#8、判断python中变量是不是字符串，采用isinstance" class="headerlink" title="8、判断python中变量是不是字符串，采用isinstance"></a>8、判断python中变量是不是字符串，采用isinstance</h3><p>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;x=&apos;abc&apos;</div><div class="line">&gt;&gt;&gt;isinstance(s,str)</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>比如下面的代码就可以判断是否是list或者tuple：其中的任意一种即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))</div><div class="line">True</div></pre></td></tr></table></figure>
<h3 id="9、生成器"><a href="#9、生成器" class="headerlink" title="9、生成器"></a>9、生成器</h3><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。<br>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：<strong>generator</strong>。</p>
<h4 id="9-1采用列表生成式创建生成器"><a href="#9-1采用列表生成式创建生成器" class="headerlink" title="9.1采用列表生成式创建生成器"></a>9.1采用列表生成式创建生成器</h4><p>只需要把“[]“——-变成——》“（）“即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</div><div class="line">&gt;&gt;&gt; L</div><div class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</div><div class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</div><div class="line">&gt;&gt;&gt; g</div><div class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</div></pre></td></tr></table></figure>
<h4 id="9-2打印生成器之——-next-不常用"><a href="#9-2打印生成器之——-next-不常用" class="headerlink" title="9.2打印生成器之——-next()不常用"></a>9.2打印生成器之——-next()不常用</h4><p>采用<code>next()</code>一个一个打印，没执行一次获得generator的下一个返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">0</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">1</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">4</div><div class="line">&gt;&gt;&gt; next(g)</div></pre></td></tr></table></figure>
<p>generator,保存的是算法，知道计算到最后一个元素，没有更多的元素时就会出现<code>StopIteration</code>的错误</p>
<h4 id="9-3打印生成器之——for迭代"><a href="#9-3打印生成器之——for迭代" class="headerlink" title="9.3打印生成器之——for迭代"></a>9.3打印生成器之——for迭代</h4><p>generator 可以采用迭代打印，这样就不需要关系<code>StopIteration</code>的错误了，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for s in g:</div><div class="line">    print(s,type(s))</div></pre></td></tr></table></figure></p>
<h4 id="9-4yield生成器"><a href="#9-4yield生成器" class="headerlink" title="9.4yield生成器"></a>9.4yield生成器</h4><p>如果一个函数中包含<code>yield</code>，那他就是生成器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 斐波那契额数列</div><div class="line">def fib(max):</div><div class="line">    pass</div><div class="line">    n,a,b=0,0,1</div><div class="line">    while n&lt;max:</div><div class="line">        yield b</div><div class="line">        a,b=b,a+b</div><div class="line">        n=n+1</div><div class="line">    return &apos;done&apos;</div></pre></td></tr></table></figure>
<p>是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在StopIteration的value中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; g = fib(6)</div><div class="line">&gt;&gt;&gt; while True:</div><div class="line">...     try:</div><div class="line">...         x = next(g)</div><div class="line">...         print(&apos;g:&apos;, x)</div><div class="line">...     except StopIteration as e:</div><div class="line">...         print(&apos;Generator return value:&apos;, e.value)</div><div class="line">...         break</div></pre></td></tr></table></figure>
<h3 id="10、迭代器"><a href="#10、迭代器" class="headerlink" title="10、迭代器"></a>10、迭代器</h3><h4 id="10-1什么是迭代器"><a href="#10-1什么是迭代器" class="headerlink" title="10.1什么是迭代器"></a>10.1什么是迭代器</h4><p>可以直接作用于for循环的数据类型有以下几种：</p>
<ul>
<li><p>一类是集合数据类型，如list、tuple、dict、set、str等；</p>
</li>
<li><p>一类是generator，包括生成器和带yield的generator function。</p>
</li>
</ul>
<p>这些可以直接作用于for循环的对象统称为可迭代对象：<strong><code>Iterable</code></strong>。<br>注意: 这仅仅是<strong>可迭代对象Iterable</strong>,不是迭代器<strong>Iterator</strong></p>
<p>迭代器(Iterator)：可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。<br>所以：list列表———&gt;可迭代对象Iterable，不是迭代器Iterator<br>            生成器———&gt;可迭代对象Iterable，也是迭代器Iterator</p>
<h4 id="10-2判断是否为可迭代对象（Iterator）—–isinstance"><a href="#10-2判断是否为可迭代对象（Iterator）—–isinstance" class="headerlink" title="10.2判断是否为可迭代对象（Iterator）—–isinstance()"></a>10.2判断是否为可迭代对象（Iterator）—–isinstance()</h4><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from collections import Iterable</div><div class="line">&gt;&gt;&gt; isinstance([], Iterable)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(100, Iterable)</div><div class="line">False</div></pre></td></tr></table></figure>
<h4 id="10-3，为什么list不是迭代器"><a href="#10-3，为什么list不是迭代器" class="headerlink" title="10.3，为什么list不是迭代器"></a>10.3，为什么list不是迭代器</h4><p>把list、dict、str等Iterable变成Iterator可以使用iter()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; isinstance(iter([]), Iterator)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)</div><div class="line">True</div></pre></td></tr></table></figure>
<p>这是因为Python的Iterator对象表示的是一个<strong>数据流</strong>，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
<h4 id="10-4、迭代器小结"><a href="#10-4、迭代器小结" class="headerlink" title="10.4、迭代器小结"></a>10.4、迭代器小结</h4><ul>
<li><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p>
</li>
<li><p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p>
</li>
<li><p>集合数据类型如<code>list、dict、str</code>等是<code>Iterable</code>但不是<code>Iterator，</code>不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p>
</li>
<li><p>Python的for循环本质上就是通过不断调用next()函数实现的</p>
</li>
<li>itertools.chain(<em>iterables)合并多个iterables<br>def chain(</em>iterables):<h1 id="chain-‘ABC’-‘DEF’-–-gt-A-B-C-D-E-F"><a href="#chain-‘ABC’-‘DEF’-–-gt-A-B-C-D-E-F" class="headerlink" title="chain(‘ABC’, ‘DEF’) –&gt; A B C D E F"></a>chain(‘ABC’, ‘DEF’) –&gt; A B C D E F</h1>  for it in iterables:<pre><code>for element in it:
    yield element
</code></pre></li>
</ul>
<h3 id="11、高阶函数"><a href="#11、高阶函数" class="headerlink" title="11、高阶函数"></a>11、高阶函数</h3><h4 id="11-1、函数也是变量"><a href="#11-1、函数也是变量" class="headerlink" title="11.1、函数也是变量"></a>11.1、函数也是变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = abs(-10)</div><div class="line">&gt;&gt;&gt; x</div><div class="line">&gt;&gt;&gt; f = abs</div><div class="line">&gt;&gt;&gt; f</div><div class="line">&lt;built-in function abs&gt;</div></pre></td></tr></table></figure>
<p>结论：函数本身也可以赋值给变量，即：变量可以指向函数。<br>如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数？用代码验证一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; f = abs</div><div class="line">&gt;&gt;&gt; f(-10)</div></pre></td></tr></table></figure></p>
<p>成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p>
<h4 id="11-2、函数调用函数—-高阶函数"><a href="#11-2、函数调用函数—-高阶函数" class="headerlink" title="11.2、函数调用函数—-高阶函数"></a>11.2、函数调用函数—-高阶函数</h4><p>传入函数</p>
<p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。<br>一个最简单的高阶函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def add(x, y, f):</div><div class="line">    return f(x) + f(y)</div></pre></td></tr></table></figure>
<p>编写高阶函数，就是让函数的参数能够接收别的函数。<br>把<strong>函数作为参数传入</strong>，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。（还能动态返回一个函数）</p>
<h4 id="11-3、可变参数"><a href="#11-3、可变参数" class="headerlink" title="11.3、可变参数"></a>11.3、可变参数</h4><p>在函数参数中传入<strong>*</strong>表示可变参数，采用for循环提出数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def add(*a):</div><div class="line">	num=0</div><div class="line">	for s in a:</div><div class="line">		num =num+ s</div><div class="line">	return num</div></pre></td></tr></table></figure></p>
<p>甚至可以出入可变函数列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def getmul(a):</div><div class="line">	return a ** 2</div><div class="line">#传入函数列表的函数</div><div class="line">def get2(a, *f):</div><div class="line">	num = 0</div><div class="line">	for i in f:</div><div class="line">		num = num + i(a)</div><div class="line">	return num</div><div class="line">f = getmul</div><div class="line">print(get2(3, f))  # 9</div><div class="line">print(get2(3, f, f))  # 18</div><div class="line">print(get2(3, f, f, f))  # 27</div></pre></td></tr></table></figure>
<h3 id="12、python中的map-reduce"><a href="#12、python中的map-reduce" class="headerlink" title="12、python中的map/reduce"></a>12、python中的map/reduce</h3><p>google的三大论文<strong>：GFS、map/reduce、BigTable</strong>。必读！！！</p>
<h4 id="12-1、map。"><a href="#12-1、map。" class="headerlink" title="12.1、map。"></a>12.1、map。</h4><p>map()函数：接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<code>Iterator</code>是属于惰性求值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def f(a):</div><div class="line">	return a ** 2</div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">	mapT = map(f, (i for i in range(1,10))) # map会对list所有的元素都进行如下处理</div><div class="line">	# map属于迭代器</div><div class="line">	print(isinstance(mapT, Iterator))#----True</div><div class="line">	for i in mapT:</div><div class="line">		print(i, end=&quot;,  &quot;)#-1,  4,  9,  16,  25,  36,  49,  64,  81,</div></pre></td></tr></table></figure>
<p>map能作用很多方面，比如把所有元素变成字符串，只需一行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</div><div class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]</div></pre></td></tr></table></figure>
<h4 id="12-2、reduce"><a href="#12-2、reduce" class="headerlink" title="12.2、reduce"></a>12.2、reduce</h4><p>导入模块：<code>from functools import reduce</code><br>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</div></pre></td></tr></table></figure>
<p>比如一个序列求和，就能采用此方式。下例算1-9的和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;rt = reduce(f, (i for i in range(1,10)))</div><div class="line">45</div></pre></td></tr></table></figure></p>
<p>当然求和运算可以直接用Python内建函数<code>sum()</code>，没必要动用reduce。</p>
<h3 id="13、lambda的使用"><a href="#13、lambda的使用" class="headerlink" title="13、lambda的使用,"></a>13、lambda的使用,</h3><p>lambda是用来创建匿名函数：更准确的说lambda是一个表达式.<br>Python lambda语法：</p>
<blockquote>
<p>lambda [arg1[,arg2,arg3….argN]] : expression</p>
</blockquote>
<p>Python允许单行快速定义一个最小函数，这便是lambda函数;<br>lambda会创建一个函数对象，但不会把这个函数对象赋给一个标识符，而def则会把函数对象赋值给一个变量<br>常用函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def add(x,y):</div><div class="line">	return x+y</div></pre></td></tr></table></figure>
<p>若采用lambda函数简化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add_by_lambda=lambda x,y : x+y</div><div class="line">print(add_by_lambda(1,2))#-----&gt;3</div></pre></td></tr></table></figure>
<p>甚至还可以直接在后面追加实参来直接获取返回值，比如<code>(lambda x, y: x + y)(2,3)</code>返回结果就是5</p>
<h4 id="14、高阶函数之—–filter的使用"><a href="#14、高阶函数之—–filter的使用" class="headerlink" title="14、高阶函数之—–filter的使用"></a>14、高阶函数之—–filter的使用</h4><p>filter用于过滤序列，对满足返回值为True的序列值保留，False剔除。<br>eg,序列只保留奇数，去除偶数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def is_odd(n):</div><div class="line">    return n % 2 == 1</div><div class="line">list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</div><div class="line"># 结果: [1, 5, 9, 15]</div></pre></td></tr></table></figure>
<p>注意到filter()函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。</p>
<h4 id="15、排序算法—–sorted"><a href="#15、排序算法—–sorted" class="headerlink" title="15、排序算法—–sorted"></a>15、排序算法—–sorted</h4><p>sorted对列表排序，但是并不改变原列表，而是从新生成一个新的排好序的列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])</div><div class="line">[-21, -12, 5, 9, 36]</div></pre></td></tr></table></figure></p>
<p><code>sorted()函数</code>也是一个高阶函数，它还可以接收一个<code>key函数</code>来实现自定义的排序，例如按绝对值大小排序：</p>
<p>key指定的函数将作用于list的每一个元素上，<strong>并根据key函数返回的结果进行排序</strong>。对比原始的list和经过key=abs处理过的list。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)</div><div class="line">[5, 9, -12, -21, 36]</div></pre></td></tr></table></figure>
<p>我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。返回结果还是原来的list，<strong>值得注意的是，这次是str函数而不是某个函数传入值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower)</div><div class="line">[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;]</div></pre></td></tr></table></figure></p>
<p>反向排序我们只需传入第三个参数即可reverse=True</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)</div><div class="line">[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]</div></pre></td></tr></table></figure>
<h3 id="16、返回函数和匿名函数"><a href="#16、返回函数和匿名函数" class="headerlink" title="16、返回函数和匿名函数"></a>16、返回函数和匿名函数</h3><h4 id="16-1、返回函数"><a href="#16-1、返回函数" class="headerlink" title="16.1、返回函数"></a>16.1、返回函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def lazy_sum(*args):</div><div class="line">    def sum():</div><div class="line">        ax = 0</div><div class="line">        for n in args:</div><div class="line">            ax = ax + n</div><div class="line">        return ax</div><div class="line">    return sum</div></pre></td></tr></table></figure>
<p>调用返回结果：最开始只是函数变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)</div><div class="line">&gt;&gt;&gt; f</div><div class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;</div><div class="line">#调用函数f时，才真正计算求和的结果：</div><div class="line">&gt;&gt;&gt; f()</div><div class="line">25</div></pre></td></tr></table></figure>
<p>在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，<strong>相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力</strong><br>返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子<br>特别注意以下的闭包:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def count():</div><div class="line">    fs = []</div><div class="line">    for i in range(1, 4):</div><div class="line">        def f():</div><div class="line">             return i*i</div><div class="line">        fs.append(f)</div><div class="line">    return fs</div><div class="line">f1, f2, f3 = count()</div><div class="line">&gt;&gt;&gt; f1() #输出结果</div><div class="line">9</div><div class="line">&gt;&gt;&gt; f2()</div><div class="line">9</div><div class="line">&gt;&gt;&gt; f3()</div><div class="line">9</div></pre></td></tr></table></figure></p>
<p>原以为输出1,4,9，结果全是9，原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。</p>
<p><font color="red"><strong>返回闭包时牢记的一点就是：返回函数不要引用任何外函数的循环变量，或者后续会发生变化的变量。</strong></font></p>
<h3 id="17、装饰者"><a href="#17、装饰者" class="headerlink" title="17、装饰者"></a>17、装饰者</h3><p>python中，一个函数也是一个对象，所以函数对象也有<code>__name__</code>属性，可以得到函数的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; abs.__name__</div><div class="line">&apos;abs&apos;</div></pre></td></tr></table></figure>
<p>假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在<strong>代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</strong><br>decorator就是一个<strong>接收函数为参数，并且返回也是函数的高阶函数</strong>。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p>
<ul>
<li>带一个星号（*）参数的函数传入的参数存储为一个元组（tuple）；</li>
<li>带两个星号（*）参数的函数传入的参数则存储为一个字典（dict），并且在<br>调用是采取 a = 1, b = 2, c = 3 的形式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def log(func):</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print(&apos;call %s():&apos; % func.__name__)</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div><div class="line">log</div><div class="line">def now():</div><div class="line">    print(&apos;2015-3-25&apos;)</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#执行</div><div class="line">&gt;&gt;&gt; now()</div><div class="line">call now():</div><div class="line">2015-3-25</div></pre></td></tr></table></figure>
<p>这里相当于调用了<code>now = log(now)</code>方法，但此时的函数名会产生变化。<br>一个完整的decorator写法：<br><code>@functools.wraps(func)</code>是为了让，原函数的函数名等未产生变化，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import functools</div><div class="line">def log(func):</div><div class="line">    @functools.wraps(func)</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print(&apos;call %s():&apos; % func.__name__)</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div></pre></td></tr></table></figure></p>
<p>当然带<strong>参数的decorator</strong>的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import functools</div><div class="line"></div><div class="line">def log(text):</div><div class="line">    def decorator(func):</div><div class="line">        @functools.wraps(func)</div><div class="line">        def wrapper(*args, **kw):</div><div class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</div><div class="line">            return func(*args, **kw)</div><div class="line">        return wrapper</div><div class="line">    return decorator</div></pre></td></tr></table></figure>
<p>作业：<br>编写一个decorator，</p>
<ul>
<li>能在函数调用的前后打印出’begin call’和’end call’的日志。</li>
<li>能否写出一个@log的decorator，使它既支持：<code>@log</code>又支持<code>@log(&#39;execute&#39;)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">def log2(text=None):</div><div class="line">	def decorator(func):</div><div class="line">		print(&apos;start call&apos;)</div><div class="line">		@functools.wraps(func)</div><div class="line">		def wrapper(*args, **kw):</div><div class="line">		</div><div class="line">			print(text, &apos;%s():&apos; % func.__name__)</div><div class="line">			#先执行，然后打印，再返回结果</div><div class="line">			x = func(*args, **kw)</div><div class="line">			print(&apos;end call&apos;)</div><div class="line">			return x</div><div class="line">		return wrapper</div><div class="line">	#这里不加这一句就会报错</div><div class="line">	if isinstance(text, str):</div><div class="line">		return decorator</div><div class="line">	else:</div><div class="line">		return decorator(text)</div></pre></td></tr></table></figure>
<p>不传参的情况下，logs(info=None) 会请求一个info参数，这时就直接把 f 传进去了，decorator(func) 请求的参数就缺失了。<br>会报错 TypeError: decorator() missing 1 required positional argument: ‘func’<br>而直接使用：f = logs()(f) 这种明确语法就没有问题~</p>
<h3 id="18、偏函数—–functools-partial"><a href="#18、偏函数—–functools-partial" class="headerlink" title="18、偏函数—–functools.partial"></a>18、偏函数—–functools.partial</h3><p>类似于包装器，直接可以固定住原函数的参数，<br>eg，<code>int(&#39;123&#39;)</code>中默认以十进制转123，但还有一个base参数确认进制。<code>int(&#39;12345&#39;,base=8)</code>结果是5349<br>当我们需要转为2进制时，又不想多次输出参数可以用偏函数进行封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import functools</div><div class="line">&gt;&gt;&gt; int2 = functools.partial(int, base=2)</div><div class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;)</div><div class="line">64</div></pre></td></tr></table></figure>
<p>还有一种情况，默认添加参数，比如<br>max2 = functools.partial(max, 10)<br>实际上会把10作为*args的一部分自动加到左边，也就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">max2(5, 6, 7)----------》args = (10, 5, 6, 7)</div><div class="line">						max(*args)</div></pre></td></tr></table></figure>
<h3 id="19、备注："><a href="#19、备注：" class="headerlink" title="19、备注："></a>19、备注：</h3><h4 id="19-1、重要的内置函数"><a href="#19-1、重要的内置函数" class="headerlink" title="19.1、重要的内置函数"></a>19.1、重要的内置函数</h4><ul>
<li>abs(numbers)                           返回一个数的绝对值</li>
<li>apply(func[,arg[,kwargs]])             调用给定的函数，可选择提供参数</li>
<li>all(iterable)                          如果所有iterable的元素均为真则返回True,否则返回False</li>
<li>any(iterable)                          如果有任一iterable的元素为真则返回True,否则返回False</li>
<li>basestring()                           str和unicode抽象超类，取决于obj的布尔值</li>
<li>callable(obj)                          检查对象是否可调用</li>
<li>char(number)                           返回ASCII为给定的字符</li>
<li>classmethod(func)                      通过一个实例方法创建类的方法</li>
<li>cmp(x,y)                               比较x,y。x<y:返回负数;x>y:返回正数;x==y,返回0</y:返回负数;x></li>
<li>complex(real[,imag])                   返回给定实部的复数</li>
<li>delattr([mapping-or-sequence])         从给定的对象中删除给定的属性</li>
<li>dict([mapping-or-sequence])            构造字典，可选择从键值对组成的列表构造。也可以用关键字参数调用</li>
<li>dir(object)                            列出给定对象的大多数特性</li>
<li>divmod(a,b)                            返回(a//b,a%b)</li>
<li>enumerate(iterable)                    对iterable所有项进行迭代</li>
<li>eval(string[,globals[,locals]])        对包含表达式的字符串进行计算。可选择给定的全局或局部作用域中进行</li>
<li>execfile(file[,globals[,locals]])      执行一个Python文件，可选在给定全局或者局部作用域中进行</li>
<li>file(filename[,mode[,bufsize]])        创建给定文件名的文件，可选择使用给定的模式和缓存区大小</li>
<li>float(object)                          将字符串或者数值转换为浮点型</li>
<li>frozenset([iterable])                  创建一个不可变集合，这意味着不能将它添加到其他集合中</li>
<li>getattr(object,name[,default])         返回给定对象中指定的特性的值，可选择给定默认值</li>
<li>globals()                              返回表示当前作用域的字典</li>
<li>hasattr(object,name)                   检查给定的对象是否有指定的属性</li>
<li>help([object])                         调用内置的帮助系统，或打印给定对象的帮助信息</li>
<li>hex(number)                            将数字转换为十六进制表示的字符串</li>
<li>id(object)                             返回给定对象的唯一ID</li>
<li>input([prompt])                        等同于eval(raw_input(prompt))</li>
<li>int(object[,radix])                    将字符串或者数字转换为整数</li>
<li>isinstance(object,classinfo)           检查给定的对象是否是给定的classinfo值的实例<pre><code>classinfo可以是类对象、类型对象或者类对象和类型对象的元祖
</code></pre></li>
<li>issubclass(class1,class2)              检查class1是否是class2的子类</li>
<li>iter(object[,sentinel])                返回一个迭代对象，可以用于迭代序列的object_iter()迭代器，或者提供一个sentinel,<pre><code>迭代器会在每次迭代中调用object,真到返回sentinel
</code></pre></li>
<li>len(object)                            返回给定对象的长度</li>
<li>list([object])                         构造一个列表</li>
<li>locals()                               返回表示当前局部作用域的字典</li>
<li>long(object[,radix])                   将字符串或者数字转换为长整形</li>
<li>map(function,seq1,…)                 创建给定函数func应用到列表seq中每一项时返回的值组成的列表</li>
<li>max(obj1[,obj2]…)                    如果obj1为非空序列，则返回最大的元素;否则返回所提供参数的最大值  </li>
<li>mix(obj1[,obj2]…)                    如果obj1为非空序列，则返回最小的元素;否则返回所提供参数的最小值       </li>
<li>object()                               返回所有新式类的基数Object的实例</li>
<li>oct(number)                            将整型转换为八进制表示的字符串</li>
<li>open(filename[,mode[,bufsize]])        file的别名，在打开文件的时候使用open而不是file</li>
<li>pow(x,y[,z])                           返回x的y次方，可选择模除z</li>
<li>ord(char)                              返回给定单字符的ASCII值</li>
<li>range([start,]stop[,step])             使用给定的起始值和结束值来创建数值范围</li>
<li>property(fget[,fset[,fdel[,doc]]])     通过一组访问器创建属性</li>
<li>raw_input([prompt])                    将用户输入的数据作为字符串返回，可选择使用给定的提示符prompt</li>
<li>reduce(func,seq[,initializer])         将序列的所有渐增应用给定的函数，使用累积的结果作为第一个参数<pre><code>所有的项作为第二个参数，可选择给定起始值
</code></pre></li>
<li>reload(module)                         重载入一个已经载入的模块并且将其返回</li>
<li>repr(object)                           返回表示对象的字符串，一般作为eval的参数使用</li>
<li>reversed(object)                       返回序列的反向迭代器</li>
<li>round(float[,n])                       将给定的浮点四舍五入，小数点后保留n位</li>
<li>set([iterable])                        返回从iterable生成的元素集合</li>
<li>setattr(object,name,value)             设定给定对象的指定属性的值为给定值</li>
<li>sorted(iterable[,cmp][,key][,reverse]) 从iterable中返回一个新排序后的列表，可选的参数和列表方法sort中的参数相同</li>
<li>staticmethod(func)                     从一个实例方法创建静态类方法</li>
<li>str(object)                            返回表示给定对象object的格式化好的字符串</li>
<li>sum(seq[,start])                       返回添加到可选参数start中的一系列数字的和</li>
<li>super(type[,obj/type])                 返回给定类型的超类</li>
<li>tuple([sequence])                      构造一个元祖,可选择使用sequence一样的项</li>
<li>type(object)                           返回给定对象的类型</li>
<li>type(name,bases,dict)                  使用给定的名称，基类和作用域返回一个新的类型对象</li>
<li>unichr(number)                         chr的Unicode版本</li>
<li>unicode(object[,encoding[,errors]])    返回给定对象的Unicode编码版本，可以给定编码方式和错误处理模式</li>
<li>vars([object])                         返回表示局部作用于的字典，或者对应给定对象特性的字典</li>
<li>xrange([start,]stop[,step])            类似于range，但是返回的对象使用较少的内存，而且只用于迭代</li>
<li>zip(seq1,…)                          返回元祖的列表，每个元祖包括一个给定序列中的项。返回长度以最小为准.<h4 id="19-2、列表的方法"><a href="#19-2、列表的方法" class="headerlink" title="19.2、列表的方法"></a>19.2、列表的方法</h4></li>
<li>L.append(obj)                          等同于L[len(L):len(L)] = [obj]</li>
<li>L.count(obj)                           返回L[i] == obj中索引为i的值</li>
<li>L.extend(obj)                          等同于L[len(L):len(L)] = seq</li>
<li>L.index(obj)                           返回L[i] == obj中最小的i,不存在会触发ValueError异常</li>
<li>L.insert(index,obj)                    index&gt;0,等同于L[index:index]=[obj],index&lt;0,插入列表最前面</li>
<li>L.pop([index])                         移除并且返回给定索引的项(默认为:-1即最后一项)  </li>
<li>L.remove(obj)                          等同于L[L.index(obj)]    </li>
<li>L.sort([cmp][,key][,reverse])          对L中的项进行原地排序。可以提供比较函数cmp<pre><code>创建用于排序的键的key函数和reverse标志进行自定义
</code></pre><h4 id="19-3、字典的方法"><a href="#19-3、字典的方法" class="headerlink" title="19.3、字典的方法"></a>19.3、字典的方法</h4></li>
<li>D.clear()                              移除D中的所有项</li>
<li>D.copy()                               返回D的副本</li>
<li>D.fromkeys(seq[,val])                  返回从seq中获得的键和被设置为val的值的字典。可做类方法调用</li>
<li>D.get(key[,default])                   如果D[key]存在，将其返回；否则返回给定的默认值None</li>
<li>D.has_key(key)                         检查D是否有给定键key</li>
<li>D.items()                              返回表示D项的(键，值)对列表</li>
<li>D.iteritems()                          从D.items()返回的(键，值)对中返回一个可迭代的对象</li>
<li>D.iterkeys()                           从D的键中返回一个可迭代对象</li>
<li>D.itervalues()                         从D的值中返回一个可迭代对象</li>
<li>D.keys()                               返回D键的列表</li>
<li>D.pop(key[,d])                         移除并且返回对应给定键key或给定的默认值D的值</li>
<li>D.popitem()                            从D中移除任意一项，并将其作为(键，值)对返回</li>
<li>D.setdefault(key[,default])            如果D[key]存在则将其返回；否则返回默认值None</li>
<li>D.update(other)                        将other中的每一项加入到D中。</li>
<li>D.values()                             返回D中值的列表</li>
</ul>
<h4 id="19-4、字符串的方法"><a href="#19-4、字符串的方法" class="headerlink" title="19.4、字符串的方法"></a>19.4、字符串的方法</h4><ul>
<li>S.capitalize()                          返回首字母大写的字符串的副本</li>
<li>S.center(width[,fillchar])              返回一个长度为max(len(S),width),S居中，两侧fillchar填充</li>
<li>S.count(sub[,start[,end]])              计算子字符串sub的出现次数，可将搜索范围限制为S[start:end]</li>
<li>S.decode([encoding[,error]])            返回使用给定编码方式的字符串的解码版本，由error指定错误处理方式</li>
<li>S.endswith(suffix[start[,end]])         检查S是否以suffix结尾，可给定[start:end]来选择匹配的范围</li>
<li>S.expandtabs([tabsize])                 返回字符串的副本，其中tab字符会使用空格进行扩展，可选择tabsize</li>
<li>S.find(sun[,start[,end]])               返回子字符串sub的第一个索引，不存在则为-1,可选择搜索范围</li>
<li>S.index(sub[,start[,end]])              返回子字符串sub的第一个索引，不存在则引发- ValueError异常.</li>
<li>S.isalnum()                             检查字符串是否由字母或数字字符组成</li>
<li>S.isalpha()                             检查字符串是否由字母字符组成</li>
<li>S.isdigit()                             检查字符串是否由数字字符组成</li>
<li>S.islower()                             检查字符串是否由小写字母组成</li>
<li>S.isspace()                             检查字符串是否由空格组成</li>
<li>S.istitle()                             检查字符串时候首字母大写</li>
<li>S.isupper()                             检查字符串是否由大写字母组成</li>
<li>S.join(sequence)                        返回其中sequence的字符串元素由S连接的字符串</li>
<li>S.ljust(width[,fillchar])               返回S副本左对齐的字符串,长度max(len(S),W),右侧fillchar填充</li>
<li>S.lower()                               返回所有字符串都为小写的副本</li>
<li>S.lstrip([char])                        向左移除所有char，默认移除(空格,tab,\n)</li>
<li>S.partition(seq)                        在字符串中搜索seq并返回</li>
<li>S.replace(old,new[,max])                将new替换olad,最多可替换max次</li>
<li>S.rfind(sub[,start[,end]])              返回sub所在的最后一个索引，不存在则为-1,可定搜索范围S[start:end]</li>
<li>S.rindex(sub[,start[,end]])             返回sub所在的最后一个索引，不存在则会引发ValueError异常。</li>
<li>S.rjust(width[,fillchar])               返回S副本右对齐的字符串,长度max(len(S),W),左侧fillchar填充</li>
<li>S.rpartition(seq)                       同Partition,但从右侧开始查找</li>
<li>S.rstip([char])                         向右移除所有char，默认移除(空格,tab,\n)</li>
<li>S.rsplit(sep[,maxsplit])                同split,但是使用maxsplit时是从右往左进行计数</li>
<li>S.split(sep[,maxsplit])                 使用sep做为分割符,可使用maxsplit指定最大切分数</li>
<li>S.zfill(width)                          在S的左侧以0填充width个字符</li>
<li>S.upper()                               返回S的副本，所有字符大写</li>
<li>S.splitlines([keepends])                返回S中所有行的列表，可选择是否包括换行符</li>
<li>S.startswith(prefix[,start[,end]])      检查S是否以prefix开始，可用[start,end]来定义范围</li>
<li>S.strip([chars])                        移除所有字符串中含chars的字符，默认移除(空格，tab,\n)</li>
<li>S.swapcase()                            返回S的副本，所有大小写交换</li>
<li>S.title()                               返回S的副本，所有单词以大写字母开头</li>
<li>S.translate(table[,deletechars])        返回S的副本，所有字符都使用table进行的转换，<pre><code>可选择删除出现在deletechars中的所有字符
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;俗话说：好记性不如烂笔头，所以对于很多细节知识点我个人喜欢记录下来，本篇博文主要是学习&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000&quot;&gt;廖雪峰的python教程&lt;/a&gt;从中总结需要掌握的部分知识点，记录下来方便以后查询&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>HBase伪分布式搭建</title>
    <link href="http://yoursite.com/2017/05/06/hbase/HBase%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2017/05/06/hbase/HBase伪分布式搭建/</id>
    <published>2017-05-06T07:58:34.005Z</published>
    <updated>2017-12-14T18:48:35.520Z</updated>
    
    <content type="html"><![CDATA[<p>主要讲解了Linux系统的部分设置，CDH版本的hdfs，hadoop，Hbase的伪分布式搭建。<br><a id="more"></a></p>
<h1 id="HBase伪分布式搭建"><a href="#HBase伪分布式搭建" class="headerlink" title="HBase伪分布式搭建"></a>HBase伪分布式搭建</h1><p>运行环境：centos7 64位<br>vm虚拟机<br>参考地址：<a href="http://www.jikexueyuan.com/course/2089_3.html?ss=1" target="_blank" rel="external">http://www.jikexueyuan.com/course/2089_3.html?ss=1</a></p>
<h2 id="1、关闭防火墙和SELinux"><a href="#1、关闭防火墙和SELinux" class="headerlink" title="1、关闭防火墙和SELinux"></a>1、关闭防火墙和SELinux</h2><h3 id="1-1-1防火墙关闭"><a href="#1-1-1防火墙关闭" class="headerlink" title="1.1.1防火墙关闭"></a>1.1.1防火墙关闭</h3><p>centos7以下的6版本都是采用iptables进行防火墙设置，centos从7开始默认用的是firewalld，这个是基于iptables的，虽然有iptables的核心，但是iptables的服务是没安装的。所以你只要停止firewalld服务即可： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl stop firewalld.service &amp;&amp; sudo systemctl disable firewalld.service</div></pre></td></tr></table></figure>
<p>或者（这是我采用的方法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service firewalld stop</div></pre></td></tr></table></figure>
<p>不过上面这一条只是临时关闭防火墙，所以还的加一条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig firewalld off</div></pre></td></tr></table></figure>
<p>如果你要改用iptables的话，需要安装iptables服务： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo yum install iptables-services </div><div class="line">sudo systemctl enable iptables &amp;&amp; sudo systemctl enable ip6tables </div><div class="line">sudo systemctl start iptables &amp;&amp; sudo systemctl start ip6tables</div></pre></td></tr></table></figure>
<h3 id="1-1-2SELinux的关闭"><a href="#1-1-2SELinux的关闭" class="headerlink" title="1.1.2SELinux的关闭"></a>1.1.2SELinux的关闭</h3><p>只需要改变一个文件夹内容即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysconfig/selinux</div></pre></td></tr></table></figure>
<p>修改文件中的selinux为disabled即可<br><img src="/images/hbase/1479823243416.png" alt="Alt text"></p>
<h2 id="2、配置IP、DNS"><a href="#2、配置IP、DNS" class="headerlink" title="2、配置IP、DNS"></a>2、配置IP、DNS</h2><p>这里ip我暂时还未配置，只是让ip地址能够成功上网就行<br>具体为<br>首先虚拟机与主机的链接方式为NAT<br><img src="/images/hbase/1479865806710.png" alt="Alt text"><br>修改一个配置文件，<br><img src="/images/hbase/1479865726599.png" alt="Alt text"><br><img src="/images/hbase/1479865950243.png" alt="Alt text"></p>
<p><strong><em> 将最后一行的ONBOOT=no改为ONBOOT=yes,如图<br>最后输入:wq 保存并退出，再重启一下network： </em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service network restart</div></pre></td></tr></table></figure>
<p>测试：<br><img src="/images/hbase/1479865989095.png" alt="Alt text"><br>就能上网了</p>
<h2 id="3、配置主机名"><a href="#3、配置主机名" class="headerlink" title="3、配置主机名"></a>3、配置主机名</h2><ul>
<li>所以需要配置主机名:配置方法</li>
</ul>
<ol>
<li><p>方式1:命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hostnamectl set-hostname locallinux（主机名，可随意）</div></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件<br>在CentOS6及其以下版本一般通过修改配置文件的办法来修改主机名，此配置文件一般为/etc/sysconfig/network，但在CentOS7中，很多系统管理工具都被替换了，所以需要在/etc/hostname中修改（参考：<a href="http://www.centoscn.com/CentOS/2015/0620/5700.html）" target="_blank" rel="external">http://www.centoscn.com/CentOS/2015/0620/5700.html）</a></p>
</li>
</ol>
<ul>
<li>修改完主机名后记得修改ip映射关系，在/etc/hosts中添加前面是本机linux的ip地址，后面是主机名<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192.168.120.128  locallinux</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4、设置SSH免密码登录"><a href="#4、设置SSH免密码登录" class="headerlink" title="4、设置SSH免密码登录"></a>4、设置SSH免密码登录</h2><p>生成秘钥：输入ssh-keygen -t rsa，然后输入四个回车<br><img src="/images/hbase/1479866320592.png" alt="Alt text"><br>拷贝秘钥：<br><img src="/images/hbase/1479866471036.png" alt="Alt text"></p>
<h2 id="5、安装JDK"><a href="#5、安装JDK" class="headerlink" title="5、安装JDK"></a>5、安装JDK</h2><p>新建文件夹—&gt;然后拷贝jdk的安装解压包到该路径下,解压,改名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir  /usr/jvm</div><div class="line">cp ../jdk-7u25-linux-x64.tar.gz    /usr/jvm</div><div class="line">cd /usr/jvm</div><div class="line">tar -zxvf jdk-7u25-linux-x64.tar.gz</div><div class="line">mv jdk1.7.25 jdk7</div></pre></td></tr></table></figure>
<p>更改环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div></pre></td></tr></table></figure></p>
<p>在尾部添加环境变量配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">JAVA_HOME=/usr/jvm/jdk7</div><div class="line">JRE_HOME=/usr/java/jdk7/jre</div><div class="line">CLASS_PATH=.:$JRE_HOME/lib:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div><div class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</div><div class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</div></pre></td></tr></table></figure>
<p>查看版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure>
<p><img src="/images/hbase/1479863068190.png" alt="Alt text"></p>
<p>可以发现原本的open-jdk仍然占据主导地位,此时java -version的时候还会发现java版本还是 OpenJDK。这个时候进入/usr/bin目录  查找java  javac 可以发现，这两个符号链接指向系统默认的jdk目录。删除java javac并且把新的java命令放在其中</p>
<p>具体操作如下：<br><img src="/images/hbase/1479863536751.png" alt="Alt text"><br>这下可以发现新的jdk已经代替了原来的</p>
<h2 id="6、Hadoop环境搭建"><a href="#6、Hadoop环境搭建" class="headerlink" title="6、Hadoop环境搭建"></a>6、Hadoop环境搭建</h2><h3 id="6-6-1、下载编译"><a href="#6-6-1、下载编译" class="headerlink" title="6.6.1、下载编译"></a>6.6.1、下载编译</h3><p>我是把个大数据的软件都放在一起的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir /usr/local/bigdata</div><div class="line">cd /usr/local/bigdata</div><div class="line">mkdir tools</div><div class="line">mkdir software</div></pre></td></tr></table></figure></p>
<p>tools文件夹下放入的是软件压缩包<br>software中是存放的个软件<br>上传hadoop的压缩包<br>具体下载地址为：<a href="http://www.apache.org/dyn/closer.cgi/hadoop/common" target="_blank" rel="external">http://www.apache.org/dyn/closer.cgi/hadoop/common</a><br>上传到tools文件夹下，解压(注意此处-C是大写的)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxf hadoop-2.7.2.tar.gz -C ../software/</div></pre></td></tr></table></figure>
<h3 id="6-6-2、配置HDFS、YARN"><a href="#6-6-2、配置HDFS、YARN" class="headerlink" title="6.6.2、配置HDFS、YARN"></a>6.6.2、配置HDFS、YARN</h3><p>总共配置了如下5个文件<br><img src="/images/hbase/1479886023478.png" alt="Alt text"></p>
<h4 id="6-6-2-1配置HDFS"><a href="#6-6-2-1配置HDFS" class="headerlink" title="6.6.2.1配置HDFS"></a>6.6.2.1配置HDFS</h4><p>然后采用noteapp++的插件nppftp对linux中的文件进行修改<br>插件下载位置：<a href="https://sourceforge.net/projects/nppftp/?source=typ_redirect" target="_blank" rel="external">https://sourceforge.net/projects/nppftp/?source=typ_redirect</a><br>然后放入noteapp下的plugins文件夹下<br><img src="/images/hbase/1479870868947.png" alt="Alt text"></p>
<ul>
<li>重启noteapp++:<br><img src="/images/hbase/1479870893274.png" alt="Alt text"></li>
<li>配置ftp：<br><img src="/images/hbase/1479871660459.png" alt="Alt text"><br>链接后，这样就能看到链接的linux结构目录</li>
<li>查看官方文档开始配置：<a href="http://hadoop.apache.org/docs/r2.7.3/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="external">http://hadoop.apache.org/docs/r2.7.3/hadoop-project-dist/hadoop-common/SingleCluster.html</a><br>首先进入hadoop2.7.2/etc/hadoop目录下发现以下文件夹</li>
</ul>
<ul>
<li><p>配置hadoop-env.sh<br><img src="/images/hbase/1479873700714.png" alt="Alt text"></p>
</li>
<li><p>配置core-site.xml</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class="line">        &lt;value&gt;hdfs://192.168.120.128:9000&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<ul>
<li>配置hdfs-site.xml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</div><div class="line">        &lt;value&gt;1&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<ul>
<li>配置数据位置，默认是linux系统中的tmp文件夹但是会被系统删除<br>所以配置在另一个位置，在hadoop-2.7.2新建data<br>复制data位置信息到到配置的core-site.xml中<br><img src="/images/hbase/1479874318016.png" alt="Alt text"></li>
</ul>
<p><img src="/images/hbase/1479874278837.png" alt="Alt text"></p>
<h4 id="6-6-2-2、配置YARN"><a href="#6-6-2-2、配置YARN" class="headerlink" title="6.6.2.2、配置YARN"></a>6.6.2.2、配置YARN</h4><ul>
<li>配置mapred-site.xml<br>,先把模板改名字<br><img src="/images/hbase/1479874539411.png" alt="Alt text"></li>
</ul>
<p>指定mapreduce使用yarn（mapred-site.xml）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"> &lt;property&gt;</div><div class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</div><div class="line">        &lt;value&gt;yarn&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<ul>
<li>配置yarn-site.xml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</div><div class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<p><strong>这样我们的hadoop已经配置成功了</strong></p>
<h3 id="6-6-3、格式化-第一次启动时需要"><a href="#6-6-3、格式化-第一次启动时需要" class="headerlink" title="6.6.3、格式化(第一次启动时需要)"></a>6.6.3、格式化(第一次启动时需要)</h3><ul>
<li>第一次启动会需要格式化，回到hadoop主目录执行bin/hdfs<br><img src="/images/hbase/1479874922800.png" alt="Alt text"></li>
<li>格式化<br><img src="/images/hbase/1479875041409.png" alt="Alt text"></li>
<li>出现successful表示配置成功<br><img src="/images/hbase/1479875118214.png" alt="Alt text"><h3 id="6-6-4、启动测试"><a href="#6-6-4、启动测试" class="headerlink" title="6.6.4、启动测试"></a>6.6.4、启动测试</h3></li>
<li>启动hadoop（在hadoop2…主目录下sbin/start-dfs.sh）<br><img src="/images/hbase/1479876710914.png" alt="Alt text"></li>
<li><p>启动yarn（sbin/start-yarn.sh）<br><img src="/images/hbase/1479877251538.png" alt="Alt text"></p>
</li>
<li><p>测试一下（自带的jar执行计算文件中的单词个数）<br>创立文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/hadoop fs  -mkdir -p /user/root/mr/wc/in</div></pre></td></tr></table></figure>
</li>
</ul>
<p>-查看该文件夹已然存在<br><img src="/images/hbase/1479883950387.png" alt="Alt text"><br>-上传一个文件，我上传的是linux的配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/hadoop fs -put /etc/profile /user/root/mr/wc/in</div></pre></td></tr></table></figure>
<ul>
<li>执行wordcount<br><img src="/images/hbase/1479884591585.png" alt="Alt text"></li>
<li>查看输出文件是否生成<br><img src="/images/hbase/1479884354772.png" alt="Alt text"><br>从图中看出我们的hadoop已然搭建成功，<br>不过最后还有一步，为了让hadoop命令能在整个linux下执行，我们还需配置一下hadoop的环境变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div></pre></td></tr></table></figure>
<p>添加：</p>
<blockquote>
<p>export HADOOP_HOME=/usr/local/bigdata/software/hadoop-2.7.2/bin<br>export PATH=$PATH:$HADOOP_HOME<br>重置配置文件<br>执行hadoop<br><img src="/images/hbase/1479885204924.png" alt="Alt text"><br>这样hadoop就搭建好了</p>
</blockquote>
<h2 id="7、Hbase的环境搭建"><a href="#7、Hbase的环境搭建" class="headerlink" title="7、Hbase的环境搭建"></a>7、Hbase的环境搭建</h2><h3 id="7-1、下载解压"><a href="#7-1、下载解压" class="headerlink" title="7.1、下载解压"></a>7.1、下载解压</h3><p>从官网中下载hbase压缩文件，运行解压（注意文件目录，-C是大写）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost tools]# tar -zxf hbase-1.2.4-bin.tar.gz -C ../software/</div></pre></td></tr></table></figure>
<h3 id="7-2、配置文件"><a href="#7-2、配置文件" class="headerlink" title="7.2、配置文件"></a>7.2、配置文件</h3><p>进入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/bigdata/software/hbase-1.2.4/conf</div></pre></td></tr></table></figure>
<ul>
<li>配置java环境（hbase-env.sh）<br><img src="/images/hbase/1479886310315.png" alt="Alt text"></li>
<li>配置hbase在hdfs中的路径，文件(hbase-site.xml)先要在hbase主目录下创建data目录<br><img src="/images/hbase/1479887285515.png" alt="Alt text"></li>
<li>在regionservers输入linux的ip，该文件主要管理我们的regionsever的主机<br>-<img src="/images/hbase/1479887419826.png" alt="Alt text"><h3 id="7-3、启动测试"><a href="#7-3、启动测试" class="headerlink" title="7.3、启动测试"></a>7.3、启动测试</h3></li>
<li>首先启动zookeeper</li>
<li>然后启动master</li>
<li>最后启动regionserver<br><img src="/images/hbase/1479887716843.png" alt="Alt text"><br>jps查看<br><img src="/images/hbase/1479887881615.png" alt="Alt text"><br>从主机浏览器打开linux端口16010（有的是60010）<br><img src="/images/hbase/1479888532310.png" alt="Alt text"><br>这样表示我们的hbase安装搭建成功了！</li>
</ul>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>Hbase中的hadoop jar包替换(出现jar包不兼容问题采用采用，我使用后启动不了我的hbase shell，)<br>查看hbase的lib目录下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ls lib |grep hadoop</div><div class="line"></div><div class="line">hadoop-annotations-2.5.1-beta.jar</div><div class="line">hadoop-auth-2.5.1-beta.jar</div><div class="line">hadoop-client-2.5.1-beta.jar</div><div class="line">hadoop-common-2.5.1-beta.jar</div><div class="line">hadoop-hdfs-2.5.1-beta.jar</div><div class="line">hadoop-hdfs-2.5.1-beta-tests.jar</div><div class="line">hadoop-mapreduce-client-app-2.5.1-beta.jar</div><div class="line">hadoop-mapreduce-client-common-2.5.1-beta.jar</div><div class="line">hadoop-mapreduce-client-core-2.5.1-beta.jar</div><div class="line">hadoop-mapreduce-client-jobclient-2.5.1-beta.jar</div><div class="line">hadoop-mapreduce-client-jobclient-2.5.1-beta-tests.jar</div><div class="line">hadoop-mapreduce-client-shuffle-2.5.1-beta.jar</div><div class="line">hadoop-yarn-api-2.5.1-beta.jar</div><div class="line">hadoop-yarn-client-2.5.1-beta.jar</div><div class="line">hadoop-yarn-common-2.5.1-beta.jar</div><div class="line">hadoop-yarn-server-common-2.5.1-beta.jar</div><div class="line">hadoop-yarn-server-nodemanager-2.5.1-beta.jar</div></pre></td></tr></table></figure>
<p>看到它是基于hadoop2.5.1的，所以我们需要用我们的hadoop2.7.2下的jar包来替换2.5.1的，保证版本的一致性，hadoop下的jar包都是在$HADOOP_HOME/share/hadoop下的.</p>
<p>我们先cd 到 /home/hadoop/hbase-1.2.4/lib下运行命令： rm -rf hadoop*.jar删掉所有的hadoop相关的jar包，然后运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find /usr/local/bigdata/software/hadoop-2.7.2/share/hadoop/ -name &quot;hadoop*jar&quot; | xargs -i cp &#123;&#125; /usr/local/bigdata/software/hbase-1.2.4/lib/</div></pre></td></tr></table></figure></p>
<p> 拷贝所有hadoop2.7.2下的jar包到hbase/lib下进行hadoop版本的统一<br><strong>完结撒花！！！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要讲解了Linux系统的部分设置，CDH版本的hdfs，hadoop，Hbase的伪分布式搭建。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="HBase" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="Centos7" scheme="http://yoursite.com/tags/Centos7/"/>
    
  </entry>
  
</feed>
